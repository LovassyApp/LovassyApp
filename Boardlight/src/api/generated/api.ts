/* tslint:disable */
/* eslint-disable */
/**
 * Blueboard
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthCreateUserGroupRequestBody
 */
export interface AuthCreateUserGroupRequestBody {
    /**
     * 
     * @type {string}
     * @memberof AuthCreateUserGroupRequestBody
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthCreateUserGroupRequestBody
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface AuthCreateUserGroupResponse
 */
export interface AuthCreateUserGroupResponse {
    /**
     * 
     * @type {number}
     * @memberof AuthCreateUserGroupResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthCreateUserGroupResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthCreateUserGroupResponse
     */
    'permissions'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface AuthIndexPermissionsResponse
 */
export interface AuthIndexPermissionsResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthIndexPermissionsResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthIndexPermissionsResponse
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthIndexPermissionsResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AuthIndexPermissionsResponse
     */
    'dangerous'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthIndexUserGroupsResponse
 */
export interface AuthIndexUserGroupsResponse {
    /**
     * 
     * @type {number}
     * @memberof AuthIndexUserGroupsResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthIndexUserGroupsResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthIndexUserGroupsResponse
     */
    'permissions'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof AuthIndexUserGroupsResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthIndexUserGroupsResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AuthLoginRequestBody
 */
export interface AuthLoginRequestBody {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginRequestBody
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginRequestBody
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthLoginRequestBody
     */
    'remember': boolean;
}
/**
 * 
 * @export
 * @interface AuthLoginResponse
 */
export interface AuthLoginResponse {
    /**
     * 
     * @type {AuthLoginResponseUser}
     * @memberof AuthLoginResponse
     */
    'user'?: AuthLoginResponseUser;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponse
     */
    'token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponse
     */
    'refreshToken'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponse
     */
    'refreshTokenExpiration'?: string | null;
}
/**
 * 
 * @export
 * @interface AuthLoginResponseUser
 */
export interface AuthLoginResponseUser {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponseUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponseUser
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponseUser
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponseUser
     */
    'emailVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponseUser
     */
    'realName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponseUser
     */
    'class'?: string | null;
}
/**
 * 
 * @export
 * @interface AuthRefreshResponse
 */
export interface AuthRefreshResponse {
    /**
     * 
     * @type {AuthRefreshResponseUser}
     * @memberof AuthRefreshResponse
     */
    'user'?: AuthRefreshResponseUser;
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshResponse
     */
    'token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshResponse
     */
    'refreshToken'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshResponse
     */
    'refreshTokenExpiration'?: string;
}
/**
 * 
 * @export
 * @interface AuthRefreshResponseUser
 */
export interface AuthRefreshResponseUser {
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshResponseUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshResponseUser
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshResponseUser
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshResponseUser
     */
    'emailVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshResponseUser
     */
    'realName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshResponseUser
     */
    'class'?: string | null;
}
/**
 * 
 * @export
 * @interface AuthResetPasswordRequestBody
 */
export interface AuthResetPasswordRequestBody {
    /**
     * 
     * @type {string}
     * @memberof AuthResetPasswordRequestBody
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface AuthSendPasswordResetRequestBody
 */
export interface AuthSendPasswordResetRequestBody {
    /**
     * 
     * @type {string}
     * @memberof AuthSendPasswordResetRequestBody
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface AuthUpdateUserGroupRequestBody
 */
export interface AuthUpdateUserGroupRequestBody {
    /**
     * 
     * @type {string}
     * @memberof AuthUpdateUserGroupRequestBody
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthUpdateUserGroupRequestBody
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface AuthViewControlResponse
 */
export interface AuthViewControlResponse {
    /**
     * 
     * @type {AuthViewControlResponseUser}
     * @memberof AuthViewControlResponse
     */
    'user'?: AuthViewControlResponseUser;
    /**
     * 
     * @type {AuthViewControlResponseSession}
     * @memberof AuthViewControlResponse
     */
    'session'?: AuthViewControlResponseSession;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthViewControlResponse
     */
    'userGroups'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthViewControlResponse
     */
    'permissions'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthViewControlResponse
     */
    'features'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface AuthViewControlResponseSession
 */
export interface AuthViewControlResponseSession {
    /**
     * 
     * @type {string}
     * @memberof AuthViewControlResponseSession
     */
    'expiry'?: string;
}
/**
 * 
 * @export
 * @interface AuthViewControlResponseUser
 */
export interface AuthViewControlResponseUser {
    /**
     * 
     * @type {string}
     * @memberof AuthViewControlResponseUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthViewControlResponseUser
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthViewControlResponseUser
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthViewControlResponseUser
     */
    'emailVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthViewControlResponseUser
     */
    'realName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthViewControlResponseUser
     */
    'class'?: string | null;
}
/**
 * 
 * @export
 * @interface AuthViewUserGroupResponse
 */
export interface AuthViewUserGroupResponse {
    /**
     * 
     * @type {number}
     * @memberof AuthViewUserGroupResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthViewUserGroupResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthViewUserGroupResponse
     */
    'permissions'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof AuthViewUserGroupResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthViewUserGroupResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ImportCreateImportKeyRequestBody
 */
export interface ImportCreateImportKeyRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ImportCreateImportKeyRequestBody
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportCreateImportKeyRequestBody
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface ImportCreateImportKeyResponse
 */
export interface ImportCreateImportKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof ImportCreateImportKeyResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportCreateImportKeyResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ImportCreateImportKeyResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ImportCreateImportKeyResponse
     */
    'key'?: string | null;
}
/**
 * 
 * @export
 * @interface ImportImportGradesRequestBody
 */
export interface ImportImportGradesRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ImportImportGradesRequestBody
     */
    'jsonEncrypted': string;
}
/**
 * 
 * @export
 * @interface ImportIndexImportKeysResponse
 */
export interface ImportIndexImportKeysResponse {
    /**
     * 
     * @type {number}
     * @memberof ImportIndexImportKeysResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportIndexImportKeysResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ImportIndexImportKeysResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ImportIndexImportKeysResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportIndexImportKeysResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ImportIndexUsersResponse
 */
export interface ImportIndexUsersResponse {
    /**
     * 
     * @type {string}
     * @memberof ImportIndexUsersResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportIndexUsersResponse
     */
    'omCodeHashed'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImportIndexUsersResponse
     */
    'publicKey'?: string | null;
}
/**
 * 
 * @export
 * @interface ImportUpdateImportKeyRequestBody
 */
export interface ImportUpdateImportKeyRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ImportUpdateImportKeyRequestBody
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportUpdateImportKeyRequestBody
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface ImportUpdateResetKeyPasswordRequestBody
 */
export interface ImportUpdateResetKeyPasswordRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ImportUpdateResetKeyPasswordRequestBody
     */
    'resetKeyPassword': string;
}
/**
 * 
 * @export
 * @interface ImportViewImportKeyResponse
 */
export interface ImportViewImportKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof ImportViewImportKeyResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportViewImportKeyResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ImportViewImportKeyResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ImportViewImportKeyResponse
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImportViewImportKeyResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportViewImportKeyResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance'?: string | null;
}
/**
 * 
 * @export
 * @interface SchoolIndexGradesResponse
 */
export interface SchoolIndexGradesResponse {
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponse
     */
    'subject'?: string | null;
    /**
     * 
     * @type {Array<SchoolIndexGradesResponseGrade>}
     * @memberof SchoolIndexGradesResponse
     */
    'grades'?: Array<SchoolIndexGradesResponseGrade> | null;
}
/**
 * 
 * @export
 * @interface SchoolIndexGradesResponseGrade
 */
export interface SchoolIndexGradesResponseGrade {
    /**
     * 
     * @type {number}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'uid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'subject'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'subjectCategory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'teacher'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'group'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'gradeValue'?: number;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'textGrade'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'shortTextGrade'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'evaluationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'createDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'gradeType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolIndexGradesResponseGrade
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopCreateLoloRequestRequestBody
 */
export interface ShopCreateLoloRequestRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShopCreateLoloRequestRequestBody
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateLoloRequestRequestBody
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface ShopCreateLoloRequestResponse
 */
export interface ShopCreateLoloRequestResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopCreateLoloRequestResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateLoloRequestResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateLoloRequestResponse
     */
    'body'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateLoloRequestResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateLoloRequestResponse
     */
    'acceptedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateLoloRequestResponse
     */
    'deniedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopCreateOwnedItemRequestBody
 */
export interface ShopCreateOwnedItemRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemRequestBody
     */
    'userId': string;
    /**
     * 
     * @type {number}
     * @memberof ShopCreateOwnedItemRequestBody
     */
    'productId': number;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemRequestBody
     */
    'usedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopCreateOwnedItemResponse
 */
export interface ShopCreateOwnedItemResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopCreateOwnedItemResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {ShopCreateOwnedItemResponseProduct}
     * @memberof ShopCreateOwnedItemResponse
     */
    'product'?: ShopCreateOwnedItemResponseProduct;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponse
     */
    'usedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopCreateOwnedItemResponseProduct
 */
export interface ShopCreateOwnedItemResponseProduct {
    /**
     * 
     * @type {number}
     * @memberof ShopCreateOwnedItemResponseProduct
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponseProduct
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponseProduct
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponseProduct
     */
    'richTextContent'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopCreateOwnedItemResponseProduct
     */
    'qrCodeActivated'?: boolean;
    /**
     * 
     * @type {Array<ShopCreateOwnedItemResponseProductInput>}
     * @memberof ShopCreateOwnedItemResponseProduct
     */
    'inputs'?: Array<ShopCreateOwnedItemResponseProductInput> | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponseProduct
     */
    'thumbnailUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponseProduct
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponseProduct
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopCreateOwnedItemResponseProductInput
 */
export interface ShopCreateOwnedItemResponseProductInput {
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponseProductInput
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponseProductInput
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateOwnedItemResponseProductInput
     */
    'label'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopCreateProductRequestBody
 */
export interface ShopCreateProductRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductRequestBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductRequestBody
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductRequestBody
     */
    'richTextContent': string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopCreateProductRequestBody
     */
    'visible': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShopCreateProductRequestBody
     */
    'qrCodeActivated': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ShopCreateProductRequestBody
     */
    'qrCodes': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ShopCreateProductRequestBody
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof ShopCreateProductRequestBody
     */
    'quantity': number;
    /**
     * 
     * @type {Array<ShopCreateProductRequestBodyInput>}
     * @memberof ShopCreateProductRequestBody
     */
    'inputs': Array<ShopCreateProductRequestBodyInput>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopCreateProductRequestBody
     */
    'notifiedEmails': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductRequestBody
     */
    'thumbnailUrl': string;
}
/**
 * 
 * @export
 * @interface ShopCreateProductRequestBodyInput
 */
export interface ShopCreateProductRequestBodyInput {
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductRequestBodyInput
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductRequestBodyInput
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductRequestBodyInput
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ShopCreateProductResponse
 */
export interface ShopCreateProductResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopCreateProductResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductResponse
     */
    'richTextContent'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopCreateProductResponse
     */
    'visible'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShopCreateProductResponse
     */
    'qrCodeActivated'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ShopCreateProductResponse
     */
    'qrCodes'?: Array<number> | null;
    /**
     * 
     * @type {number}
     * @memberof ShopCreateProductResponse
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopCreateProductResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {Array<ShopCreateProductResponseInput>}
     * @memberof ShopCreateProductResponse
     */
    'inputs'?: Array<ShopCreateProductResponseInput> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopCreateProductResponse
     */
    'notifiedEmails'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductResponse
     */
    'thumbnailUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopCreateProductResponseInput
 */
export interface ShopCreateProductResponseInput {
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductResponseInput
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductResponseInput
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateProductResponseInput
     */
    'label'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopCreateQRCodeRequestBody
 */
export interface ShopCreateQRCodeRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShopCreateQRCodeRequestBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateQRCodeRequestBody
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ShopCreateQRCodeResponse
 */
export interface ShopCreateQRCodeResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopCreateQRCodeResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateQRCodeResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopCreateQRCodeResponse
     */
    'email'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopIndexLoloRequestsResponse
 */
export interface ShopIndexLoloRequestsResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexLoloRequestsResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLoloRequestsResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLoloRequestsResponse
     */
    'body'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLoloRequestsResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLoloRequestsResponse
     */
    'acceptedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLoloRequestsResponse
     */
    'deniedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLoloRequestsResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLoloRequestsResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopIndexLolosResponse
 */
export interface ShopIndexLolosResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexLolosResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLolosResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopIndexLolosResponse
     */
    'isSpent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLolosResponse
     */
    'loloType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLolosResponse
     */
    'reason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLolosResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexLolosResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopIndexOwnLolosResponse
 */
export interface ShopIndexOwnLolosResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexOwnLolosResponse
     */
    'balance'?: number;
    /**
     * 
     * @type {Array<ShopIndexOwnLolosResponseCoin>}
     * @memberof ShopIndexOwnLolosResponse
     */
    'coins'?: Array<ShopIndexOwnLolosResponseCoin> | null;
}
/**
 * 
 * @export
 * @interface ShopIndexOwnLolosResponseCoin
 */
export interface ShopIndexOwnLolosResponseCoin {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexOwnLolosResponseCoin
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseCoin
     */
    'userId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopIndexOwnLolosResponseCoin
     */
    'isSpent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseCoin
     */
    'loloType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseCoin
     */
    'reason'?: string | null;
    /**
     * 
     * @type {Array<ShopIndexOwnLolosResponseGrade>}
     * @memberof ShopIndexOwnLolosResponseCoin
     */
    'grades'?: Array<ShopIndexOwnLolosResponseGrade> | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseCoin
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseCoin
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopIndexOwnLolosResponseGrade
 */
export interface ShopIndexOwnLolosResponseGrade {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'uid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'subject'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'subjectCategory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'teacher'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'group'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'gradeValue'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'textGrade'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'shortTextGrade'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'evaluationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'createDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'gradeType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnLolosResponseGrade
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopIndexOwnOwnedItemsResponse
 */
export interface ShopIndexOwnOwnedItemsResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexOwnOwnedItemsResponse
     */
    'id'?: number;
    /**
     * 
     * @type {ShopIndexOwnOwnedItemsResponseProduct}
     * @memberof ShopIndexOwnOwnedItemsResponse
     */
    'product'?: ShopIndexOwnOwnedItemsResponseProduct;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnOwnedItemsResponse
     */
    'usedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnOwnedItemsResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnOwnedItemsResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopIndexOwnOwnedItemsResponseProduct
 */
export interface ShopIndexOwnOwnedItemsResponseProduct {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexOwnOwnedItemsResponseProduct
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnOwnedItemsResponseProduct
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnOwnedItemsResponseProduct
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopIndexOwnOwnedItemsResponseProduct
     */
    'qrCodeActivated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnOwnedItemsResponseProduct
     */
    'thumbnailUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnOwnedItemsResponseProduct
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnOwnedItemsResponseProduct
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopIndexOwnedItemsResponse
 */
export interface ShopIndexOwnedItemsResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexOwnedItemsResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnedItemsResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {ShopIndexOwnedItemsResponseProduct}
     * @memberof ShopIndexOwnedItemsResponse
     */
    'product'?: ShopIndexOwnedItemsResponseProduct;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnedItemsResponse
     */
    'usedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnedItemsResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnedItemsResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopIndexOwnedItemsResponseProduct
 */
export interface ShopIndexOwnedItemsResponseProduct {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexOwnedItemsResponseProduct
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnedItemsResponseProduct
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnedItemsResponseProduct
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopIndexOwnedItemsResponseProduct
     */
    'qrCodeActivated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnedItemsResponseProduct
     */
    'thumbnailUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnedItemsResponseProduct
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexOwnedItemsResponseProduct
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopIndexProductsResponse
 */
export interface ShopIndexProductsResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexProductsResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexProductsResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexProductsResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopIndexProductsResponse
     */
    'visible'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShopIndexProductsResponse
     */
    'qrCodeActivated'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ShopIndexProductsResponse
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopIndexProductsResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexProductsResponse
     */
    'thumbnailUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexProductsResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexProductsResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopIndexQRCodesResponse
 */
export interface ShopIndexQRCodesResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopIndexQRCodesResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexQRCodesResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexQRCodesResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexQRCodesResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopIndexQRCodesResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopOverruleLoloRequestRequestBody
 */
export interface ShopOverruleLoloRequestRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof ShopOverruleLoloRequestRequestBody
     */
    'accepted': boolean;
    /**
     * 
     * @type {number}
     * @memberof ShopOverruleLoloRequestRequestBody
     */
    'loloAmount'?: number;
}
/**
 * 
 * @export
 * @interface ShopUpdateLoloRequestRequestBody
 */
export interface ShopUpdateLoloRequestRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateLoloRequestRequestBody
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateLoloRequestRequestBody
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface ShopUpdateOwnedItemRequestBody
 */
export interface ShopUpdateOwnedItemRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateOwnedItemRequestBody
     */
    'usedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopUpdateProductRequestBody
 */
export interface ShopUpdateProductRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateProductRequestBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateProductRequestBody
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateProductRequestBody
     */
    'richTextContent': string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopUpdateProductRequestBody
     */
    'visible': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShopUpdateProductRequestBody
     */
    'qrCodeActivated': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ShopUpdateProductRequestBody
     */
    'qrCodes': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ShopUpdateProductRequestBody
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof ShopUpdateProductRequestBody
     */
    'quantity': number;
    /**
     * 
     * @type {Array<ShopUpdateProductRequestBodyInput>}
     * @memberof ShopUpdateProductRequestBody
     */
    'inputs': Array<ShopUpdateProductRequestBodyInput>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopUpdateProductRequestBody
     */
    'notifiedEmails': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateProductRequestBody
     */
    'thumbnailUrl': string;
}
/**
 * 
 * @export
 * @interface ShopUpdateProductRequestBodyInput
 */
export interface ShopUpdateProductRequestBodyInput {
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateProductRequestBodyInput
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateProductRequestBodyInput
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateProductRequestBodyInput
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ShopUpdateQRCodeRequestBody
 */
export interface ShopUpdateQRCodeRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateQRCodeRequestBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShopUpdateQRCodeRequestBody
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ShopUseOwnedItemRequestBody
 */
export interface ShopUseOwnedItemRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShopUseOwnedItemRequestBody
     */
    'qrCodeContent'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ShopUseOwnedItemRequestBody
     */
    'inputs'?: { [key: string]: string; } | null;
}
/**
 * 
 * @export
 * @interface ShopViewLoloRequestResponse
 */
export interface ShopViewLoloRequestResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopViewLoloRequestResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopViewLoloRequestResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewLoloRequestResponse
     */
    'body'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewLoloRequestResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopViewLoloRequestResponse
     */
    'acceptedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewLoloRequestResponse
     */
    'deniedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewLoloRequestResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopViewLoloRequestResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopViewOwnedItemResponse
 */
export interface ShopViewOwnedItemResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopViewOwnedItemResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {ShopViewOwnedItemResponseProduct}
     * @memberof ShopViewOwnedItemResponse
     */
    'product'?: ShopViewOwnedItemResponseProduct;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponse
     */
    'usedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopViewOwnedItemResponseProduct
 */
export interface ShopViewOwnedItemResponseProduct {
    /**
     * 
     * @type {number}
     * @memberof ShopViewOwnedItemResponseProduct
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponseProduct
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponseProduct
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponseProduct
     */
    'richTextContent'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopViewOwnedItemResponseProduct
     */
    'qrCodeActivated'?: boolean;
    /**
     * 
     * @type {Array<ShopViewOwnedItemResponseProductInput>}
     * @memberof ShopViewOwnedItemResponseProduct
     */
    'inputs'?: Array<ShopViewOwnedItemResponseProductInput> | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponseProduct
     */
    'thumbnailUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponseProduct
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponseProduct
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopViewOwnedItemResponseProductInput
 */
export interface ShopViewOwnedItemResponseProductInput {
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponseProductInput
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponseProductInput
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewOwnedItemResponseProductInput
     */
    'label'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopViewProductResponse
 */
export interface ShopViewProductResponse {
    /**
     * 
     * @type {number}
     * @memberof ShopViewProductResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponse
     */
    'richTextContent'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopViewProductResponse
     */
    'visible'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShopViewProductResponse
     */
    'qrCodeActivated'?: boolean;
    /**
     * 
     * @type {Array<ShopViewProductResponseQRCode>}
     * @memberof ShopViewProductResponse
     */
    'qrCodes'?: Array<ShopViewProductResponseQRCode> | null;
    /**
     * 
     * @type {number}
     * @memberof ShopViewProductResponse
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopViewProductResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {Array<ShopViewProductResponseInput>}
     * @memberof ShopViewProductResponse
     */
    'inputs'?: Array<ShopViewProductResponseInput> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopViewProductResponse
     */
    'notifiedEmails'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponse
     */
    'thumbnailUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ShopViewProductResponseInput
 */
export interface ShopViewProductResponseInput {
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponseInput
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponseInput
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponseInput
     */
    'label'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopViewProductResponseQRCode
 */
export interface ShopViewProductResponseQRCode {
    /**
     * 
     * @type {number}
     * @memberof ShopViewProductResponseQRCode
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopViewProductResponseQRCode
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface StatusNotifyOnResetKeyPasswordSetRequestBody
 */
export interface StatusNotifyOnResetKeyPasswordSetRequestBody {
    /**
     * 
     * @type {string}
     * @memberof StatusNotifyOnResetKeyPasswordSetRequestBody
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface StatusViewServiceStatusResponse
 */
export interface StatusViewServiceStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof StatusViewServiceStatusResponse
     */
    'ready'?: boolean;
    /**
     * 
     * @type {StatusViewServiceStatusResponseServiceStatus}
     * @memberof StatusViewServiceStatusResponse
     */
    'serviceStatus'?: StatusViewServiceStatusResponseServiceStatus;
}
/**
 * 
 * @export
 * @interface StatusViewServiceStatusResponseServiceStatus
 */
export interface StatusViewServiceStatusResponseServiceStatus {
    /**
     * 
     * @type {boolean}
     * @memberof StatusViewServiceStatusResponseServiceStatus
     */
    'database'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StatusViewServiceStatusResponseServiceStatus
     */
    'realtime'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StatusViewServiceStatusResponseServiceStatus
     */
    'resetKeyPassword'?: boolean;
}
/**
 * 
 * @export
 * @interface StatusViewVersionRequestBody
 */
export interface StatusViewVersionRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof StatusViewVersionRequestBody
     */
    'sendOk': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StatusViewVersionRequestBody
     */
    'sendMOTD': boolean;
}
/**
 * 
 * @export
 * @interface StatusViewVersionResponse
 */
export interface StatusViewVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusViewVersionResponse
     */
    'whoAmI'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatusViewVersionResponse
     */
    'version'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatusViewVersionResponse
     */
    'dotNetVersion'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatusViewVersionResponse
     */
    'contributors'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof StatusViewVersionResponse
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatusViewVersionResponse
     */
    'motd'?: string | null;
}
/**
 * 
 * @export
 * @interface UsersCreateUserRequestBody
 */
export interface UsersCreateUserRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UsersCreateUserRequestBody
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UsersCreateUserRequestBody
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UsersCreateUserRequestBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UsersCreateUserRequestBody
     */
    'omCode': string;
}
/**
 * 
 * @export
 * @interface UsersIndexUsersResponse
 */
export interface UsersIndexUsersResponse {
    /**
     * 
     * @type {string}
     * @memberof UsersIndexUsersResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersIndexUsersResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersIndexUsersResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersIndexUsersResponse
     */
    'emailVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersIndexUsersResponse
     */
    'realName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersIndexUsersResponse
     */
    'class'?: string | null;
    /**
     * 
     * @type {Array<UsersIndexUsersResponseUserGroup>}
     * @memberof UsersIndexUsersResponse
     */
    'userGroups'?: Array<UsersIndexUsersResponseUserGroup> | null;
    /**
     * 
     * @type {string}
     * @memberof UsersIndexUsersResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersIndexUsersResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UsersIndexUsersResponseUserGroup
 */
export interface UsersIndexUsersResponseUserGroup {
    /**
     * 
     * @type {number}
     * @memberof UsersIndexUsersResponseUserGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersIndexUsersResponseUserGroup
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface UsersUpdateUserRequestBody
 */
export interface UsersUpdateUserRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UsersUpdateUserRequestBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UsersUpdateUserRequestBody
     */
    'email': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UsersUpdateUserRequestBody
     */
    'userGroups': Array<number>;
}
/**
 * 
 * @export
 * @interface UsersViewUserResponse
 */
export interface UsersViewUserResponse {
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponse
     */
    'emailVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponse
     */
    'realName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponse
     */
    'class'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponse
     */
    'lastOnlineAt'?: string | null;
    /**
     * 
     * @type {Array<UsersViewUserResponseUserGroup>}
     * @memberof UsersViewUserResponse
     */
    'userGroups'?: Array<UsersViewUserResponseUserGroup> | null;
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UsersViewUserResponseUserGroup
 */
export interface UsersViewUserResponseUserGroup {
    /**
     * 
     * @type {number}
     * @memberof UsersViewUserResponseUserGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersViewUserResponseUserGroup
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UsersViewUserResponseUserGroup
     */
    'permissions'?: Array<string> | null;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires one of the following permissions</b>: Auth.Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthControlGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Auth/Control`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthLoginRequestBody} [authLoginRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost: async (authLoginRequestBody?: AuthLoginRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Auth/Login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLogoutDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Auth/Logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthRefreshPost: async (token?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Auth/Refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires unverified email</b>
         * @param {string} [verifyUrl] 
         * @param {string} [verifyTokenQueryKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthResendVerifyEmailPost: async (verifyUrl?: string, verifyTokenQueryKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Auth/ResendVerifyEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (verifyUrl !== undefined) {
                localVarQueryParameter['verifyUrl'] = verifyUrl;
            }

            if (verifyTokenQueryKey !== undefined) {
                localVarQueryParameter['verifyTokenQueryKey'] = verifyTokenQueryKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [passwordResetToken] 
         * @param {AuthResetPasswordRequestBody} [authResetPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthResetPasswordPost: async (passwordResetToken?: string, authResetPasswordRequestBody?: AuthResetPasswordRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Auth/ResetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (passwordResetToken !== undefined) {
                localVarQueryParameter['passwordResetToken'] = passwordResetToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResetPasswordRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [passwordResetUrl] 
         * @param {string} [passwordResetTokenQueryKey] 
         * @param {AuthSendPasswordResetRequestBody} [authSendPasswordResetRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSendPasswordResetPost: async (passwordResetUrl?: string, passwordResetTokenQueryKey?: string, authSendPasswordResetRequestBody?: AuthSendPasswordResetRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Auth/SendPasswordReset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (passwordResetUrl !== undefined) {
                localVarQueryParameter['passwordResetUrl'] = passwordResetUrl;
            }

            if (passwordResetTokenQueryKey !== undefined) {
                localVarQueryParameter['passwordResetTokenQueryKey'] = passwordResetTokenQueryKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSendPasswordResetRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [verifyToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthVerifyEmailPost: async (verifyToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Auth/VerifyEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (verifyToken !== undefined) {
                localVarQueryParameter['verifyToken'] = verifyToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires one of the following permissions</b>: Auth.Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthControlGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthViewControlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthControlGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AuthLoginRequestBody} [authLoginRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthLoginPost(authLoginRequestBody?: AuthLoginRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthLoginPost(authLoginRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthLogoutDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthLogoutDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthRefreshPost(token?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRefreshResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthRefreshPost(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires unverified email</b>
         * @param {string} [verifyUrl] 
         * @param {string} [verifyTokenQueryKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthResendVerifyEmailPost(verifyUrl?: string, verifyTokenQueryKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthResendVerifyEmailPost(verifyUrl, verifyTokenQueryKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [passwordResetToken] 
         * @param {AuthResetPasswordRequestBody} [authResetPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthResetPasswordPost(passwordResetToken?: string, authResetPasswordRequestBody?: AuthResetPasswordRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthResetPasswordPost(passwordResetToken, authResetPasswordRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [passwordResetUrl] 
         * @param {string} [passwordResetTokenQueryKey] 
         * @param {AuthSendPasswordResetRequestBody} [authSendPasswordResetRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthSendPasswordResetPost(passwordResetUrl?: string, passwordResetTokenQueryKey?: string, authSendPasswordResetRequestBody?: AuthSendPasswordResetRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthSendPasswordResetPost(passwordResetUrl, passwordResetTokenQueryKey, authSendPasswordResetRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [verifyToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthVerifyEmailPost(verifyToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthVerifyEmailPost(verifyToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * <b>Requires one of the following permissions</b>: Auth.Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthControlGet(options?: AxiosRequestConfig): AxiosPromise<AuthViewControlResponse> {
            return localVarFp.apiAuthControlGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthApiApiAuthLoginPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost(requestParameters: AuthApiApiAuthLoginPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AuthLoginResponse> {
            return localVarFp.apiAuthLoginPost(requestParameters.authLoginRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLogoutDelete(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAuthLogoutDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthApiApiAuthRefreshPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthRefreshPost(requestParameters: AuthApiApiAuthRefreshPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AuthRefreshResponse> {
            return localVarFp.apiAuthRefreshPost(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires unverified email</b>
         * @param {AuthApiApiAuthResendVerifyEmailPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthResendVerifyEmailPost(requestParameters: AuthApiApiAuthResendVerifyEmailPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAuthResendVerifyEmailPost(requestParameters.verifyUrl, requestParameters.verifyTokenQueryKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthApiApiAuthResetPasswordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthResetPasswordPost(requestParameters: AuthApiApiAuthResetPasswordPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAuthResetPasswordPost(requestParameters.passwordResetToken, requestParameters.authResetPasswordRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthApiApiAuthSendPasswordResetPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSendPasswordResetPost(requestParameters: AuthApiApiAuthSendPasswordResetPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAuthSendPasswordResetPost(requestParameters.passwordResetUrl, requestParameters.passwordResetTokenQueryKey, requestParameters.authSendPasswordResetRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthApiApiAuthVerifyEmailPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthVerifyEmailPost(requestParameters: AuthApiApiAuthVerifyEmailPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAuthVerifyEmailPost(requestParameters.verifyToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiAuthLoginPost operation in AuthApi.
 * @export
 * @interface AuthApiApiAuthLoginPostRequest
 */
export interface AuthApiApiAuthLoginPostRequest {
    /**
     * 
     * @type {AuthLoginRequestBody}
     * @memberof AuthApiApiAuthLoginPost
     */
    readonly authLoginRequestBody?: AuthLoginRequestBody
}

/**
 * Request parameters for apiAuthRefreshPost operation in AuthApi.
 * @export
 * @interface AuthApiApiAuthRefreshPostRequest
 */
export interface AuthApiApiAuthRefreshPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiApiAuthRefreshPost
     */
    readonly token?: string
}

/**
 * Request parameters for apiAuthResendVerifyEmailPost operation in AuthApi.
 * @export
 * @interface AuthApiApiAuthResendVerifyEmailPostRequest
 */
export interface AuthApiApiAuthResendVerifyEmailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiApiAuthResendVerifyEmailPost
     */
    readonly verifyUrl?: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiApiAuthResendVerifyEmailPost
     */
    readonly verifyTokenQueryKey?: string
}

/**
 * Request parameters for apiAuthResetPasswordPost operation in AuthApi.
 * @export
 * @interface AuthApiApiAuthResetPasswordPostRequest
 */
export interface AuthApiApiAuthResetPasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiApiAuthResetPasswordPost
     */
    readonly passwordResetToken?: string

    /**
     * 
     * @type {AuthResetPasswordRequestBody}
     * @memberof AuthApiApiAuthResetPasswordPost
     */
    readonly authResetPasswordRequestBody?: AuthResetPasswordRequestBody
}

/**
 * Request parameters for apiAuthSendPasswordResetPost operation in AuthApi.
 * @export
 * @interface AuthApiApiAuthSendPasswordResetPostRequest
 */
export interface AuthApiApiAuthSendPasswordResetPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiApiAuthSendPasswordResetPost
     */
    readonly passwordResetUrl?: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiApiAuthSendPasswordResetPost
     */
    readonly passwordResetTokenQueryKey?: string

    /**
     * 
     * @type {AuthSendPasswordResetRequestBody}
     * @memberof AuthApiApiAuthSendPasswordResetPost
     */
    readonly authSendPasswordResetRequestBody?: AuthSendPasswordResetRequestBody
}

/**
 * Request parameters for apiAuthVerifyEmailPost operation in AuthApi.
 * @export
 * @interface AuthApiApiAuthVerifyEmailPostRequest
 */
export interface AuthApiApiAuthVerifyEmailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiApiAuthVerifyEmailPost
     */
    readonly verifyToken?: string
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * <b>Requires one of the following permissions</b>: Auth.Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthControlGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthControlGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthApiApiAuthLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthLoginPost(requestParameters: AuthApiApiAuthLoginPostRequest = {}, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthLoginPost(requestParameters.authLoginRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthLogoutDelete(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthLogoutDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthApiApiAuthRefreshPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthRefreshPost(requestParameters: AuthApiApiAuthRefreshPostRequest = {}, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthRefreshPost(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires unverified email</b>
     * @param {AuthApiApiAuthResendVerifyEmailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthResendVerifyEmailPost(requestParameters: AuthApiApiAuthResendVerifyEmailPostRequest = {}, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthResendVerifyEmailPost(requestParameters.verifyUrl, requestParameters.verifyTokenQueryKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthApiApiAuthResetPasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthResetPasswordPost(requestParameters: AuthApiApiAuthResetPasswordPostRequest = {}, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthResetPasswordPost(requestParameters.passwordResetToken, requestParameters.authResetPasswordRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthApiApiAuthSendPasswordResetPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthSendPasswordResetPost(requestParameters: AuthApiApiAuthSendPasswordResetPostRequest = {}, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthSendPasswordResetPost(requestParameters.passwordResetUrl, requestParameters.passwordResetTokenQueryKey, requestParameters.authSendPasswordResetRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthApiApiAuthVerifyEmailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthVerifyEmailPost(requestParameters: AuthApiApiAuthVerifyEmailPostRequest = {}, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthVerifyEmailPost(requestParameters.verifyToken, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GradesApi - axios parameter creator
 * @export
 */
export const GradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: School.IndexGrades<br><b>Requires the following features to be enabled</b>: School
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGradesGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Grades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GradesApi - functional programming interface
 * @export
 */
export const GradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GradesApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: School.IndexGrades<br><b>Requires the following features to be enabled</b>: School
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGradesGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SchoolIndexGradesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGradesGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GradesApi - factory interface
 * @export
 */
export const GradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GradesApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: School.IndexGrades<br><b>Requires the following features to be enabled</b>: School
         * @param {GradesApiApiGradesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGradesGet(requestParameters: GradesApiApiGradesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<SchoolIndexGradesResponse>> {
            return localVarFp.apiGradesGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiGradesGet operation in GradesApi.
 * @export
 * @interface GradesApiApiGradesGetRequest
 */
export interface GradesApiApiGradesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof GradesApiApiGradesGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof GradesApiApiGradesGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof GradesApiApiGradesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof GradesApiApiGradesGet
     */
    readonly pageSize?: number
}

/**
 * GradesApi - object-oriented interface
 * @export
 * @class GradesApi
 * @extends {BaseAPI}
 */
export class GradesApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: School.IndexGrades<br><b>Requires the following features to be enabled</b>: School
     * @param {GradesApiApiGradesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradesApi
     */
    public apiGradesGet(requestParameters: GradesApiApiGradesGetRequest = {}, options?: AxiosRequestConfig) {
        return GradesApiFp(this.configuration).apiGradesGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportApi - axios parameter creator
 * @export
 */
export const ImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires the following features to be enabled</b>: Import
         * @param {string} userId 
         * @param {ImportImportGradesRequestBody} [importImportGradesRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportGradesUserIdPost: async (userId: string, importImportGradesRequestBody?: ImportImportGradesRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiImportGradesUserIdPost', 'userId', userId)
            const localVarPath = `/Api/Import/Grades/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ImportKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importImportGradesRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires the following features to be enabled</b>: Import
         * @param {ImportUpdateResetKeyPasswordRequestBody} [importUpdateResetKeyPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportResetKeyPasswordPut: async (importUpdateResetKeyPasswordRequestBody?: ImportUpdateResetKeyPasswordRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Import/ResetKeyPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ImportKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importUpdateResetKeyPasswordRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires the following features to be enabled</b>: Import
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportUsersGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Import/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ImportKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires the following features to be enabled</b>: Import
         * @param {string} userId 
         * @param {ImportImportGradesRequestBody} [importImportGradesRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportGradesUserIdPost(userId: string, importImportGradesRequestBody?: ImportImportGradesRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportGradesUserIdPost(userId, importImportGradesRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires the following features to be enabled</b>: Import
         * @param {ImportUpdateResetKeyPasswordRequestBody} [importUpdateResetKeyPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportResetKeyPasswordPut(importUpdateResetKeyPasswordRequestBody?: ImportUpdateResetKeyPasswordRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportResetKeyPasswordPut(importUpdateResetKeyPasswordRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires the following features to be enabled</b>: Import
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportUsersGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportIndexUsersResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportUsersGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportApiFp(configuration)
    return {
        /**
         * <b>Requires the following features to be enabled</b>: Import
         * @param {ImportApiApiImportGradesUserIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportGradesUserIdPost(requestParameters: ImportApiApiImportGradesUserIdPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiImportGradesUserIdPost(requestParameters.userId, requestParameters.importImportGradesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires the following features to be enabled</b>: Import
         * @param {ImportApiApiImportResetKeyPasswordPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportResetKeyPasswordPut(requestParameters: ImportApiApiImportResetKeyPasswordPutRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiImportResetKeyPasswordPut(requestParameters.importUpdateResetKeyPasswordRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires the following features to be enabled</b>: Import
         * @param {ImportApiApiImportUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportUsersGet(requestParameters: ImportApiApiImportUsersGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<ImportIndexUsersResponse>> {
            return localVarFp.apiImportUsersGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiImportGradesUserIdPost operation in ImportApi.
 * @export
 * @interface ImportApiApiImportGradesUserIdPostRequest
 */
export interface ImportApiApiImportGradesUserIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ImportApiApiImportGradesUserIdPost
     */
    readonly userId: string

    /**
     * 
     * @type {ImportImportGradesRequestBody}
     * @memberof ImportApiApiImportGradesUserIdPost
     */
    readonly importImportGradesRequestBody?: ImportImportGradesRequestBody
}

/**
 * Request parameters for apiImportResetKeyPasswordPut operation in ImportApi.
 * @export
 * @interface ImportApiApiImportResetKeyPasswordPutRequest
 */
export interface ImportApiApiImportResetKeyPasswordPutRequest {
    /**
     * 
     * @type {ImportUpdateResetKeyPasswordRequestBody}
     * @memberof ImportApiApiImportResetKeyPasswordPut
     */
    readonly importUpdateResetKeyPasswordRequestBody?: ImportUpdateResetKeyPasswordRequestBody
}

/**
 * Request parameters for apiImportUsersGet operation in ImportApi.
 * @export
 * @interface ImportApiApiImportUsersGetRequest
 */
export interface ImportApiApiImportUsersGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ImportApiApiImportUsersGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof ImportApiApiImportUsersGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof ImportApiApiImportUsersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ImportApiApiImportUsersGet
     */
    readonly pageSize?: number
}

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
    /**
     * <b>Requires the following features to be enabled</b>: Import
     * @param {ImportApiApiImportGradesUserIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public apiImportGradesUserIdPost(requestParameters: ImportApiApiImportGradesUserIdPostRequest, options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).apiImportGradesUserIdPost(requestParameters.userId, requestParameters.importImportGradesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires the following features to be enabled</b>: Import
     * @param {ImportApiApiImportResetKeyPasswordPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public apiImportResetKeyPasswordPut(requestParameters: ImportApiApiImportResetKeyPasswordPutRequest = {}, options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).apiImportResetKeyPasswordPut(requestParameters.importUpdateResetKeyPasswordRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires the following features to be enabled</b>: Import
     * @param {ImportApiApiImportUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public apiImportUsersGet(requestParameters: ImportApiApiImportUsersGetRequest = {}, options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).apiImportUsersGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportKeysApi - axios parameter creator
 * @export
 */
export const ImportKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.IndexImportKeys<br><b>Requires the following features to be enabled</b>: Import
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/ImportKeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.DeleteImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportKeysIdDelete', 'id', id)
            const localVarPath = `/Api/ImportKeys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.ViewImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportKeysIdGet', 'id', id)
            const localVarPath = `/Api/ImportKeys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.UpdateImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {number} id 
         * @param {ImportUpdateImportKeyRequestBody} [importUpdateImportKeyRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysIdPatch: async (id: number, importUpdateImportKeyRequestBody?: ImportUpdateImportKeyRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportKeysIdPatch', 'id', id)
            const localVarPath = `/Api/ImportKeys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importUpdateImportKeyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.CreateImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {ImportCreateImportKeyRequestBody} [importCreateImportKeyRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysPost: async (importCreateImportKeyRequestBody?: ImportCreateImportKeyRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/ImportKeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importCreateImportKeyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportKeysApi - functional programming interface
 * @export
 */
export const ImportKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.IndexImportKeys<br><b>Requires the following features to be enabled</b>: Import
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportKeysGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportIndexImportKeysResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportKeysGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.DeleteImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportKeysIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportKeysIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.ViewImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportKeysIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportViewImportKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportKeysIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.UpdateImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {number} id 
         * @param {ImportUpdateImportKeyRequestBody} [importUpdateImportKeyRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportKeysIdPatch(id: number, importUpdateImportKeyRequestBody?: ImportUpdateImportKeyRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportKeysIdPatch(id, importUpdateImportKeyRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.CreateImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {ImportCreateImportKeyRequestBody} [importCreateImportKeyRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportKeysPost(importCreateImportKeyRequestBody?: ImportCreateImportKeyRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportCreateImportKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportKeysPost(importCreateImportKeyRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportKeysApi - factory interface
 * @export
 */
export const ImportKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportKeysApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.IndexImportKeys<br><b>Requires the following features to be enabled</b>: Import
         * @param {ImportKeysApiApiImportKeysGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysGet(requestParameters: ImportKeysApiApiImportKeysGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<ImportIndexImportKeysResponse>> {
            return localVarFp.apiImportKeysGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.DeleteImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {ImportKeysApiApiImportKeysIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysIdDelete(requestParameters: ImportKeysApiApiImportKeysIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiImportKeysIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.ViewImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {ImportKeysApiApiImportKeysIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysIdGet(requestParameters: ImportKeysApiApiImportKeysIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ImportViewImportKeyResponse> {
            return localVarFp.apiImportKeysIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.UpdateImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {ImportKeysApiApiImportKeysIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysIdPatch(requestParameters: ImportKeysApiApiImportKeysIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiImportKeysIdPatch(requestParameters.id, requestParameters.importUpdateImportKeyRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.CreateImportKey<br><b>Requires the following features to be enabled</b>: Import
         * @param {ImportKeysApiApiImportKeysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportKeysPost(requestParameters: ImportKeysApiApiImportKeysPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ImportCreateImportKeyResponse> {
            return localVarFp.apiImportKeysPost(requestParameters.importCreateImportKeyRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiImportKeysGet operation in ImportKeysApi.
 * @export
 * @interface ImportKeysApiApiImportKeysGetRequest
 */
export interface ImportKeysApiApiImportKeysGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ImportKeysApiApiImportKeysGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof ImportKeysApiApiImportKeysGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof ImportKeysApiApiImportKeysGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ImportKeysApiApiImportKeysGet
     */
    readonly pageSize?: number
}

/**
 * Request parameters for apiImportKeysIdDelete operation in ImportKeysApi.
 * @export
 * @interface ImportKeysApiApiImportKeysIdDeleteRequest
 */
export interface ImportKeysApiApiImportKeysIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof ImportKeysApiApiImportKeysIdDelete
     */
    readonly id: number
}

/**
 * Request parameters for apiImportKeysIdGet operation in ImportKeysApi.
 * @export
 * @interface ImportKeysApiApiImportKeysIdGetRequest
 */
export interface ImportKeysApiApiImportKeysIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ImportKeysApiApiImportKeysIdGet
     */
    readonly id: number
}

/**
 * Request parameters for apiImportKeysIdPatch operation in ImportKeysApi.
 * @export
 * @interface ImportKeysApiApiImportKeysIdPatchRequest
 */
export interface ImportKeysApiApiImportKeysIdPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof ImportKeysApiApiImportKeysIdPatch
     */
    readonly id: number

    /**
     * 
     * @type {ImportUpdateImportKeyRequestBody}
     * @memberof ImportKeysApiApiImportKeysIdPatch
     */
    readonly importUpdateImportKeyRequestBody?: ImportUpdateImportKeyRequestBody
}

/**
 * Request parameters for apiImportKeysPost operation in ImportKeysApi.
 * @export
 * @interface ImportKeysApiApiImportKeysPostRequest
 */
export interface ImportKeysApiApiImportKeysPostRequest {
    /**
     * 
     * @type {ImportCreateImportKeyRequestBody}
     * @memberof ImportKeysApiApiImportKeysPost
     */
    readonly importCreateImportKeyRequestBody?: ImportCreateImportKeyRequestBody
}

/**
 * ImportKeysApi - object-oriented interface
 * @export
 * @class ImportKeysApi
 * @extends {BaseAPI}
 */
export class ImportKeysApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.IndexImportKeys<br><b>Requires the following features to be enabled</b>: Import
     * @param {ImportKeysApiApiImportKeysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportKeysApi
     */
    public apiImportKeysGet(requestParameters: ImportKeysApiApiImportKeysGetRequest = {}, options?: AxiosRequestConfig) {
        return ImportKeysApiFp(this.configuration).apiImportKeysGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.DeleteImportKey<br><b>Requires the following features to be enabled</b>: Import
     * @param {ImportKeysApiApiImportKeysIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportKeysApi
     */
    public apiImportKeysIdDelete(requestParameters: ImportKeysApiApiImportKeysIdDeleteRequest, options?: AxiosRequestConfig) {
        return ImportKeysApiFp(this.configuration).apiImportKeysIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.ViewImportKey<br><b>Requires the following features to be enabled</b>: Import
     * @param {ImportKeysApiApiImportKeysIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportKeysApi
     */
    public apiImportKeysIdGet(requestParameters: ImportKeysApiApiImportKeysIdGetRequest, options?: AxiosRequestConfig) {
        return ImportKeysApiFp(this.configuration).apiImportKeysIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.UpdateImportKey<br><b>Requires the following features to be enabled</b>: Import
     * @param {ImportKeysApiApiImportKeysIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportKeysApi
     */
    public apiImportKeysIdPatch(requestParameters: ImportKeysApiApiImportKeysIdPatchRequest, options?: AxiosRequestConfig) {
        return ImportKeysApiFp(this.configuration).apiImportKeysIdPatch(requestParameters.id, requestParameters.importUpdateImportKeyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Import.CreateImportKey<br><b>Requires the following features to be enabled</b>: Import
     * @param {ImportKeysApiApiImportKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportKeysApi
     */
    public apiImportKeysPost(requestParameters: ImportKeysApiApiImportKeysPostRequest = {}, options?: AxiosRequestConfig) {
        return ImportKeysApiFp(this.configuration).apiImportKeysPost(requestParameters.importCreateImportKeyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoloRequestsApi - axios parameter creator
 * @export
 */
export const LoloRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexLoloRequests<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/LoloRequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteOwnLoloRequest, Shop.DeleteLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiLoloRequestsIdDelete', 'id', id)
            const localVarPath = `/Api/LoloRequests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiLoloRequestsIdGet', 'id', id)
            const localVarPath = `/Api/LoloRequests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateOwnLoloRequest, Shop.UpdateLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopUpdateLoloRequestRequestBody} [shopUpdateLoloRequestRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsIdPatch: async (id: number, shopUpdateLoloRequestRequestBody?: ShopUpdateLoloRequestRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiLoloRequestsIdPatch', 'id', id)
            const localVarPath = `/Api/LoloRequests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopUpdateLoloRequestRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.OverruleLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopOverruleLoloRequestRequestBody} [shopOverruleLoloRequestRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsOverruleIdPost: async (id: number, shopOverruleLoloRequestRequestBody?: ShopOverruleLoloRequestRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiLoloRequestsOverruleIdPost', 'id', id)
            const localVarPath = `/Api/LoloRequests/Overrule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopOverruleLoloRequestRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {ShopCreateLoloRequestRequestBody} [shopCreateLoloRequestRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsPost: async (shopCreateLoloRequestRequestBody?: ShopCreateLoloRequestRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/LoloRequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopCreateLoloRequestRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoloRequestsApi - functional programming interface
 * @export
 */
export const LoloRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoloRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexLoloRequests<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLoloRequestsGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShopIndexLoloRequestsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLoloRequestsGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteOwnLoloRequest, Shop.DeleteLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLoloRequestsIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLoloRequestsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLoloRequestsIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopViewLoloRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLoloRequestsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateOwnLoloRequest, Shop.UpdateLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopUpdateLoloRequestRequestBody} [shopUpdateLoloRequestRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLoloRequestsIdPatch(id: number, shopUpdateLoloRequestRequestBody?: ShopUpdateLoloRequestRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLoloRequestsIdPatch(id, shopUpdateLoloRequestRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.OverruleLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopOverruleLoloRequestRequestBody} [shopOverruleLoloRequestRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLoloRequestsOverruleIdPost(id: number, shopOverruleLoloRequestRequestBody?: ShopOverruleLoloRequestRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLoloRequestsOverruleIdPost(id, shopOverruleLoloRequestRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {ShopCreateLoloRequestRequestBody} [shopCreateLoloRequestRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLoloRequestsPost(shopCreateLoloRequestRequestBody?: ShopCreateLoloRequestRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopCreateLoloRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLoloRequestsPost(shopCreateLoloRequestRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoloRequestsApi - factory interface
 * @export
 */
export const LoloRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoloRequestsApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexLoloRequests<br><b>Requires the following features to be enabled</b>: Shop
         * @param {LoloRequestsApiApiLoloRequestsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsGet(requestParameters: LoloRequestsApiApiLoloRequestsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<ShopIndexLoloRequestsResponse>> {
            return localVarFp.apiLoloRequestsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteOwnLoloRequest, Shop.DeleteLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {LoloRequestsApiApiLoloRequestsIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsIdDelete(requestParameters: LoloRequestsApiApiLoloRequestsIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiLoloRequestsIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {LoloRequestsApiApiLoloRequestsIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsIdGet(requestParameters: LoloRequestsApiApiLoloRequestsIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ShopViewLoloRequestResponse> {
            return localVarFp.apiLoloRequestsIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateOwnLoloRequest, Shop.UpdateLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {LoloRequestsApiApiLoloRequestsIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsIdPatch(requestParameters: LoloRequestsApiApiLoloRequestsIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiLoloRequestsIdPatch(requestParameters.id, requestParameters.shopUpdateLoloRequestRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.OverruleLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {LoloRequestsApiApiLoloRequestsOverruleIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsOverruleIdPost(requestParameters: LoloRequestsApiApiLoloRequestsOverruleIdPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiLoloRequestsOverruleIdPost(requestParameters.id, requestParameters.shopOverruleLoloRequestRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
         * @param {LoloRequestsApiApiLoloRequestsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLoloRequestsPost(requestParameters: LoloRequestsApiApiLoloRequestsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopCreateLoloRequestResponse> {
            return localVarFp.apiLoloRequestsPost(requestParameters.shopCreateLoloRequestRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiLoloRequestsGet operation in LoloRequestsApi.
 * @export
 * @interface LoloRequestsApiApiLoloRequestsGetRequest
 */
export interface LoloRequestsApiApiLoloRequestsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof LoloRequestsApiApiLoloRequestsGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof LoloRequestsApiApiLoloRequestsGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof LoloRequestsApiApiLoloRequestsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LoloRequestsApiApiLoloRequestsGet
     */
    readonly pageSize?: number
}

/**
 * Request parameters for apiLoloRequestsIdDelete operation in LoloRequestsApi.
 * @export
 * @interface LoloRequestsApiApiLoloRequestsIdDeleteRequest
 */
export interface LoloRequestsApiApiLoloRequestsIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof LoloRequestsApiApiLoloRequestsIdDelete
     */
    readonly id: number
}

/**
 * Request parameters for apiLoloRequestsIdGet operation in LoloRequestsApi.
 * @export
 * @interface LoloRequestsApiApiLoloRequestsIdGetRequest
 */
export interface LoloRequestsApiApiLoloRequestsIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof LoloRequestsApiApiLoloRequestsIdGet
     */
    readonly id: number
}

/**
 * Request parameters for apiLoloRequestsIdPatch operation in LoloRequestsApi.
 * @export
 * @interface LoloRequestsApiApiLoloRequestsIdPatchRequest
 */
export interface LoloRequestsApiApiLoloRequestsIdPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof LoloRequestsApiApiLoloRequestsIdPatch
     */
    readonly id: number

    /**
     * 
     * @type {ShopUpdateLoloRequestRequestBody}
     * @memberof LoloRequestsApiApiLoloRequestsIdPatch
     */
    readonly shopUpdateLoloRequestRequestBody?: ShopUpdateLoloRequestRequestBody
}

/**
 * Request parameters for apiLoloRequestsOverruleIdPost operation in LoloRequestsApi.
 * @export
 * @interface LoloRequestsApiApiLoloRequestsOverruleIdPostRequest
 */
export interface LoloRequestsApiApiLoloRequestsOverruleIdPostRequest {
    /**
     * 
     * @type {number}
     * @memberof LoloRequestsApiApiLoloRequestsOverruleIdPost
     */
    readonly id: number

    /**
     * 
     * @type {ShopOverruleLoloRequestRequestBody}
     * @memberof LoloRequestsApiApiLoloRequestsOverruleIdPost
     */
    readonly shopOverruleLoloRequestRequestBody?: ShopOverruleLoloRequestRequestBody
}

/**
 * Request parameters for apiLoloRequestsPost operation in LoloRequestsApi.
 * @export
 * @interface LoloRequestsApiApiLoloRequestsPostRequest
 */
export interface LoloRequestsApiApiLoloRequestsPostRequest {
    /**
     * 
     * @type {ShopCreateLoloRequestRequestBody}
     * @memberof LoloRequestsApiApiLoloRequestsPost
     */
    readonly shopCreateLoloRequestRequestBody?: ShopCreateLoloRequestRequestBody
}

/**
 * LoloRequestsApi - object-oriented interface
 * @export
 * @class LoloRequestsApi
 * @extends {BaseAPI}
 */
export class LoloRequestsApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexLoloRequests<br><b>Requires the following features to be enabled</b>: Shop
     * @param {LoloRequestsApiApiLoloRequestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoloRequestsApi
     */
    public apiLoloRequestsGet(requestParameters: LoloRequestsApiApiLoloRequestsGetRequest = {}, options?: AxiosRequestConfig) {
        return LoloRequestsApiFp(this.configuration).apiLoloRequestsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteOwnLoloRequest, Shop.DeleteLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
     * @param {LoloRequestsApiApiLoloRequestsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoloRequestsApi
     */
    public apiLoloRequestsIdDelete(requestParameters: LoloRequestsApiApiLoloRequestsIdDeleteRequest, options?: AxiosRequestConfig) {
        return LoloRequestsApiFp(this.configuration).apiLoloRequestsIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
     * @param {LoloRequestsApiApiLoloRequestsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoloRequestsApi
     */
    public apiLoloRequestsIdGet(requestParameters: LoloRequestsApiApiLoloRequestsIdGetRequest, options?: AxiosRequestConfig) {
        return LoloRequestsApiFp(this.configuration).apiLoloRequestsIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateOwnLoloRequest, Shop.UpdateLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
     * @param {LoloRequestsApiApiLoloRequestsIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoloRequestsApi
     */
    public apiLoloRequestsIdPatch(requestParameters: LoloRequestsApiApiLoloRequestsIdPatchRequest, options?: AxiosRequestConfig) {
        return LoloRequestsApiFp(this.configuration).apiLoloRequestsIdPatch(requestParameters.id, requestParameters.shopUpdateLoloRequestRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.OverruleLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
     * @param {LoloRequestsApiApiLoloRequestsOverruleIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoloRequestsApi
     */
    public apiLoloRequestsOverruleIdPost(requestParameters: LoloRequestsApiApiLoloRequestsOverruleIdPostRequest, options?: AxiosRequestConfig) {
        return LoloRequestsApiFp(this.configuration).apiLoloRequestsOverruleIdPost(requestParameters.id, requestParameters.shopOverruleLoloRequestRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateLoloRequest<br><b>Requires the following features to be enabled</b>: Shop
     * @param {LoloRequestsApiApiLoloRequestsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoloRequestsApi
     */
    public apiLoloRequestsPost(requestParameters: LoloRequestsApiApiLoloRequestsPostRequest = {}, options?: AxiosRequestConfig) {
        return LoloRequestsApiFp(this.configuration).apiLoloRequestsPost(requestParameters.shopCreateLoloRequestRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LolosApi - axios parameter creator
 * @export
 */
export const LolosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexLolos<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLolosGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Lolos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnLolos<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLolosOwnGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Lolos/Own`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LolosApi - functional programming interface
 * @export
 */
export const LolosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LolosApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexLolos<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLolosGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopIndexLolosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLolosGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnLolos<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLolosOwnGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopIndexOwnLolosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLolosOwnGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LolosApi - factory interface
 * @export
 */
export const LolosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LolosApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexLolos<br><b>Requires the following features to be enabled</b>: Shop
         * @param {LolosApiApiLolosGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLolosGet(requestParameters: LolosApiApiLolosGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopIndexLolosResponse> {
            return localVarFp.apiLolosGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnLolos<br><b>Requires the following features to be enabled</b>: Shop
         * @param {LolosApiApiLolosOwnGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLolosOwnGet(requestParameters: LolosApiApiLolosOwnGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopIndexOwnLolosResponse> {
            return localVarFp.apiLolosOwnGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiLolosGet operation in LolosApi.
 * @export
 * @interface LolosApiApiLolosGetRequest
 */
export interface LolosApiApiLolosGetRequest {
    /**
     * 
     * @type {string}
     * @memberof LolosApiApiLolosGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof LolosApiApiLolosGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof LolosApiApiLolosGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LolosApiApiLolosGet
     */
    readonly pageSize?: number
}

/**
 * Request parameters for apiLolosOwnGet operation in LolosApi.
 * @export
 * @interface LolosApiApiLolosOwnGetRequest
 */
export interface LolosApiApiLolosOwnGetRequest {
    /**
     * 
     * @type {string}
     * @memberof LolosApiApiLolosOwnGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof LolosApiApiLolosOwnGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof LolosApiApiLolosOwnGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LolosApiApiLolosOwnGet
     */
    readonly pageSize?: number
}

/**
 * LolosApi - object-oriented interface
 * @export
 * @class LolosApi
 * @extends {BaseAPI}
 */
export class LolosApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexLolos<br><b>Requires the following features to be enabled</b>: Shop
     * @param {LolosApiApiLolosGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LolosApi
     */
    public apiLolosGet(requestParameters: LolosApiApiLolosGetRequest = {}, options?: AxiosRequestConfig) {
        return LolosApiFp(this.configuration).apiLolosGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnLolos<br><b>Requires the following features to be enabled</b>: Shop
     * @param {LolosApiApiLolosOwnGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LolosApi
     */
    public apiLolosOwnGet(requestParameters: LolosApiApiLolosOwnGetRequest = {}, options?: AxiosRequestConfig) {
        return LolosApiFp(this.configuration).apiLolosOwnGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OwnedItemsApi - axios parameter creator
 * @export
 */
export const OwnedItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnedItems<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/OwnedItems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteOwnedItem, Shop.DeleteOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOwnedItemsIdDelete', 'id', id)
            const localVarPath = `/Api/OwnedItems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewOwnedItem, Shop.ViewOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOwnedItemsIdGet', 'id', id)
            const localVarPath = `/Api/OwnedItems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopUpdateOwnedItemRequestBody} [shopUpdateOwnedItemRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsIdPatch: async (id: number, shopUpdateOwnedItemRequestBody?: ShopUpdateOwnedItemRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOwnedItemsIdPatch', 'id', id)
            const localVarPath = `/Api/OwnedItems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopUpdateOwnedItemRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UseOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopUseOwnedItemRequestBody} [shopUseOwnedItemRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsIdUsePost: async (id: number, shopUseOwnedItemRequestBody?: ShopUseOwnedItemRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOwnedItemsIdUsePost', 'id', id)
            const localVarPath = `/Api/OwnedItems/{id}/Use`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopUseOwnedItemRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnOwnedItems<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsOwnGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/OwnedItems/Own`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {ShopCreateOwnedItemRequestBody} [shopCreateOwnedItemRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsPost: async (shopCreateOwnedItemRequestBody?: ShopCreateOwnedItemRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/OwnedItems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopCreateOwnedItemRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OwnedItemsApi - functional programming interface
 * @export
 */
export const OwnedItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OwnedItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnedItems<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOwnedItemsGet(filters?: string, sorts?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShopIndexOwnedItemsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOwnedItemsGet(filters, sorts, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteOwnedItem, Shop.DeleteOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOwnedItemsIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOwnedItemsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewOwnedItem, Shop.ViewOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOwnedItemsIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopViewOwnedItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOwnedItemsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopUpdateOwnedItemRequestBody} [shopUpdateOwnedItemRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOwnedItemsIdPatch(id: number, shopUpdateOwnedItemRequestBody?: ShopUpdateOwnedItemRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOwnedItemsIdPatch(id, shopUpdateOwnedItemRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UseOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopUseOwnedItemRequestBody} [shopUseOwnedItemRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOwnedItemsIdUsePost(id: number, shopUseOwnedItemRequestBody?: ShopUseOwnedItemRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOwnedItemsIdUsePost(id, shopUseOwnedItemRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnOwnedItems<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOwnedItemsOwnGet(filters?: string, sorts?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShopIndexOwnOwnedItemsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOwnedItemsOwnGet(filters, sorts, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {ShopCreateOwnedItemRequestBody} [shopCreateOwnedItemRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOwnedItemsPost(shopCreateOwnedItemRequestBody?: ShopCreateOwnedItemRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopCreateOwnedItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOwnedItemsPost(shopCreateOwnedItemRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OwnedItemsApi - factory interface
 * @export
 */
export const OwnedItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OwnedItemsApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnedItems<br><b>Requires the following features to be enabled</b>: Shop
         * @param {OwnedItemsApiApiOwnedItemsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsGet(requestParameters: OwnedItemsApiApiOwnedItemsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<ShopIndexOwnedItemsResponse>> {
            return localVarFp.apiOwnedItemsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteOwnedItem, Shop.DeleteOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {OwnedItemsApiApiOwnedItemsIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsIdDelete(requestParameters: OwnedItemsApiApiOwnedItemsIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiOwnedItemsIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewOwnedItem, Shop.ViewOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {OwnedItemsApiApiOwnedItemsIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsIdGet(requestParameters: OwnedItemsApiApiOwnedItemsIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ShopViewOwnedItemResponse> {
            return localVarFp.apiOwnedItemsIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {OwnedItemsApiApiOwnedItemsIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsIdPatch(requestParameters: OwnedItemsApiApiOwnedItemsIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiOwnedItemsIdPatch(requestParameters.id, requestParameters.shopUpdateOwnedItemRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UseOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {OwnedItemsApiApiOwnedItemsIdUsePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsIdUsePost(requestParameters: OwnedItemsApiApiOwnedItemsIdUsePostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiOwnedItemsIdUsePost(requestParameters.id, requestParameters.shopUseOwnedItemRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnOwnedItems<br><b>Requires the following features to be enabled</b>: Shop
         * @param {OwnedItemsApiApiOwnedItemsOwnGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsOwnGet(requestParameters: OwnedItemsApiApiOwnedItemsOwnGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<ShopIndexOwnOwnedItemsResponse>> {
            return localVarFp.apiOwnedItemsOwnGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
         * @param {OwnedItemsApiApiOwnedItemsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOwnedItemsPost(requestParameters: OwnedItemsApiApiOwnedItemsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopCreateOwnedItemResponse> {
            return localVarFp.apiOwnedItemsPost(requestParameters.shopCreateOwnedItemRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiOwnedItemsGet operation in OwnedItemsApi.
 * @export
 * @interface OwnedItemsApiApiOwnedItemsGetRequest
 */
export interface OwnedItemsApiApiOwnedItemsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof OwnedItemsApiApiOwnedItemsGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof OwnedItemsApiApiOwnedItemsGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof OwnedItemsApiApiOwnedItemsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OwnedItemsApiApiOwnedItemsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof OwnedItemsApiApiOwnedItemsGet
     */
    readonly search?: string
}

/**
 * Request parameters for apiOwnedItemsIdDelete operation in OwnedItemsApi.
 * @export
 * @interface OwnedItemsApiApiOwnedItemsIdDeleteRequest
 */
export interface OwnedItemsApiApiOwnedItemsIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof OwnedItemsApiApiOwnedItemsIdDelete
     */
    readonly id: number
}

/**
 * Request parameters for apiOwnedItemsIdGet operation in OwnedItemsApi.
 * @export
 * @interface OwnedItemsApiApiOwnedItemsIdGetRequest
 */
export interface OwnedItemsApiApiOwnedItemsIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof OwnedItemsApiApiOwnedItemsIdGet
     */
    readonly id: number
}

/**
 * Request parameters for apiOwnedItemsIdPatch operation in OwnedItemsApi.
 * @export
 * @interface OwnedItemsApiApiOwnedItemsIdPatchRequest
 */
export interface OwnedItemsApiApiOwnedItemsIdPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof OwnedItemsApiApiOwnedItemsIdPatch
     */
    readonly id: number

    /**
     * 
     * @type {ShopUpdateOwnedItemRequestBody}
     * @memberof OwnedItemsApiApiOwnedItemsIdPatch
     */
    readonly shopUpdateOwnedItemRequestBody?: ShopUpdateOwnedItemRequestBody
}

/**
 * Request parameters for apiOwnedItemsIdUsePost operation in OwnedItemsApi.
 * @export
 * @interface OwnedItemsApiApiOwnedItemsIdUsePostRequest
 */
export interface OwnedItemsApiApiOwnedItemsIdUsePostRequest {
    /**
     * 
     * @type {number}
     * @memberof OwnedItemsApiApiOwnedItemsIdUsePost
     */
    readonly id: number

    /**
     * 
     * @type {ShopUseOwnedItemRequestBody}
     * @memberof OwnedItemsApiApiOwnedItemsIdUsePost
     */
    readonly shopUseOwnedItemRequestBody?: ShopUseOwnedItemRequestBody
}

/**
 * Request parameters for apiOwnedItemsOwnGet operation in OwnedItemsApi.
 * @export
 * @interface OwnedItemsApiApiOwnedItemsOwnGetRequest
 */
export interface OwnedItemsApiApiOwnedItemsOwnGetRequest {
    /**
     * 
     * @type {string}
     * @memberof OwnedItemsApiApiOwnedItemsOwnGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof OwnedItemsApiApiOwnedItemsOwnGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof OwnedItemsApiApiOwnedItemsOwnGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OwnedItemsApiApiOwnedItemsOwnGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof OwnedItemsApiApiOwnedItemsOwnGet
     */
    readonly search?: string
}

/**
 * Request parameters for apiOwnedItemsPost operation in OwnedItemsApi.
 * @export
 * @interface OwnedItemsApiApiOwnedItemsPostRequest
 */
export interface OwnedItemsApiApiOwnedItemsPostRequest {
    /**
     * 
     * @type {ShopCreateOwnedItemRequestBody}
     * @memberof OwnedItemsApiApiOwnedItemsPost
     */
    readonly shopCreateOwnedItemRequestBody?: ShopCreateOwnedItemRequestBody
}

/**
 * OwnedItemsApi - object-oriented interface
 * @export
 * @class OwnedItemsApi
 * @extends {BaseAPI}
 */
export class OwnedItemsApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnedItems<br><b>Requires the following features to be enabled</b>: Shop
     * @param {OwnedItemsApiApiOwnedItemsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OwnedItemsApi
     */
    public apiOwnedItemsGet(requestParameters: OwnedItemsApiApiOwnedItemsGetRequest = {}, options?: AxiosRequestConfig) {
        return OwnedItemsApiFp(this.configuration).apiOwnedItemsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteOwnedItem, Shop.DeleteOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
     * @param {OwnedItemsApiApiOwnedItemsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OwnedItemsApi
     */
    public apiOwnedItemsIdDelete(requestParameters: OwnedItemsApiApiOwnedItemsIdDeleteRequest, options?: AxiosRequestConfig) {
        return OwnedItemsApiFp(this.configuration).apiOwnedItemsIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewOwnedItem, Shop.ViewOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
     * @param {OwnedItemsApiApiOwnedItemsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OwnedItemsApi
     */
    public apiOwnedItemsIdGet(requestParameters: OwnedItemsApiApiOwnedItemsIdGetRequest, options?: AxiosRequestConfig) {
        return OwnedItemsApiFp(this.configuration).apiOwnedItemsIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
     * @param {OwnedItemsApiApiOwnedItemsIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OwnedItemsApi
     */
    public apiOwnedItemsIdPatch(requestParameters: OwnedItemsApiApiOwnedItemsIdPatchRequest, options?: AxiosRequestConfig) {
        return OwnedItemsApiFp(this.configuration).apiOwnedItemsIdPatch(requestParameters.id, requestParameters.shopUpdateOwnedItemRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UseOwnOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
     * @param {OwnedItemsApiApiOwnedItemsIdUsePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OwnedItemsApi
     */
    public apiOwnedItemsIdUsePost(requestParameters: OwnedItemsApiApiOwnedItemsIdUsePostRequest, options?: AxiosRequestConfig) {
        return OwnedItemsApiFp(this.configuration).apiOwnedItemsIdUsePost(requestParameters.id, requestParameters.shopUseOwnedItemRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexOwnOwnedItems<br><b>Requires the following features to be enabled</b>: Shop
     * @param {OwnedItemsApiApiOwnedItemsOwnGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OwnedItemsApi
     */
    public apiOwnedItemsOwnGet(requestParameters: OwnedItemsApiApiOwnedItemsOwnGetRequest = {}, options?: AxiosRequestConfig) {
        return OwnedItemsApiFp(this.configuration).apiOwnedItemsOwnGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateOwnedItem<br><b>Requires the following features to be enabled</b>: Shop
     * @param {OwnedItemsApiApiOwnedItemsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OwnedItemsApi
     */
    public apiOwnedItemsPost(requestParameters: OwnedItemsApiApiOwnedItemsPostRequest = {}, options?: AxiosRequestConfig) {
        return OwnedItemsApiFp(this.configuration).apiOwnedItemsPost(requestParameters.shopCreateOwnedItemRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.IndexPermissions
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.IndexPermissions
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPermissionsGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthIndexPermissionsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPermissionsGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.IndexPermissions
         * @param {PermissionsApiApiPermissionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsGet(requestParameters: PermissionsApiApiPermissionsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AuthIndexPermissionsResponse>> {
            return localVarFp.apiPermissionsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiPermissionsGet operation in PermissionsApi.
 * @export
 * @interface PermissionsApiApiPermissionsGetRequest
 */
export interface PermissionsApiApiPermissionsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PermissionsApiApiPermissionsGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof PermissionsApiApiPermissionsGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof PermissionsApiApiPermissionsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PermissionsApiApiPermissionsGet
     */
    readonly pageSize?: number
}

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.IndexPermissions
     * @param {PermissionsApiApiPermissionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public apiPermissionsGet(requestParameters: PermissionsApiApiPermissionsGetRequest = {}, options?: AxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).apiPermissionsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.BuyProduct
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsBuyIdPost: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiProductsBuyIdPost', 'id', id)
            const localVarPath = `/Api/Products/Buy/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexProducts, Shop.IndexStoreProducts
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteProduct
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiProductsIdDelete', 'id', id)
            const localVarPath = `/Api/Products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewProduct, Shop.ViewStoreProduct
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiProductsIdGet', 'id', id)
            const localVarPath = `/Api/Products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateProduct
         * @param {number} id 
         * @param {ShopUpdateProductRequestBody} [shopUpdateProductRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsIdPatch: async (id: number, shopUpdateProductRequestBody?: ShopUpdateProductRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiProductsIdPatch', 'id', id)
            const localVarPath = `/Api/Products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopUpdateProductRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateProduct
         * @param {ShopCreateProductRequestBody} [shopCreateProductRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsPost: async (shopCreateProductRequestBody?: ShopCreateProductRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopCreateProductRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.BuyProduct
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProductsBuyIdPost(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProductsBuyIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexProducts, Shop.IndexStoreProducts
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProductsGet(filters?: string, sorts?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShopIndexProductsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProductsGet(filters, sorts, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteProduct
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProductsIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProductsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewProduct, Shop.ViewStoreProduct
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProductsIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopViewProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProductsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateProduct
         * @param {number} id 
         * @param {ShopUpdateProductRequestBody} [shopUpdateProductRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProductsIdPatch(id: number, shopUpdateProductRequestBody?: ShopUpdateProductRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProductsIdPatch(id, shopUpdateProductRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateProduct
         * @param {ShopCreateProductRequestBody} [shopCreateProductRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProductsPost(shopCreateProductRequestBody?: ShopCreateProductRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopCreateProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProductsPost(shopCreateProductRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.BuyProduct
         * @param {ProductsApiApiProductsBuyIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsBuyIdPost(requestParameters: ProductsApiApiProductsBuyIdPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiProductsBuyIdPost(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexProducts, Shop.IndexStoreProducts
         * @param {ProductsApiApiProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsGet(requestParameters: ProductsApiApiProductsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<ShopIndexProductsResponse>> {
            return localVarFp.apiProductsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteProduct
         * @param {ProductsApiApiProductsIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsIdDelete(requestParameters: ProductsApiApiProductsIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiProductsIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewProduct, Shop.ViewStoreProduct
         * @param {ProductsApiApiProductsIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsIdGet(requestParameters: ProductsApiApiProductsIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ShopViewProductResponse> {
            return localVarFp.apiProductsIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateProduct
         * @param {ProductsApiApiProductsIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsIdPatch(requestParameters: ProductsApiApiProductsIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiProductsIdPatch(requestParameters.id, requestParameters.shopUpdateProductRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateProduct
         * @param {ProductsApiApiProductsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProductsPost(requestParameters: ProductsApiApiProductsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopCreateProductResponse> {
            return localVarFp.apiProductsPost(requestParameters.shopCreateProductRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiProductsBuyIdPost operation in ProductsApi.
 * @export
 * @interface ProductsApiApiProductsBuyIdPostRequest
 */
export interface ProductsApiApiProductsBuyIdPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductsApiApiProductsBuyIdPost
     */
    readonly id: number
}

/**
 * Request parameters for apiProductsGet operation in ProductsApi.
 * @export
 * @interface ProductsApiApiProductsGetRequest
 */
export interface ProductsApiApiProductsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiApiProductsGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof ProductsApiApiProductsGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof ProductsApiApiProductsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductsApiApiProductsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProductsApiApiProductsGet
     */
    readonly search?: string
}

/**
 * Request parameters for apiProductsIdDelete operation in ProductsApi.
 * @export
 * @interface ProductsApiApiProductsIdDeleteRequest
 */
export interface ProductsApiApiProductsIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductsApiApiProductsIdDelete
     */
    readonly id: number
}

/**
 * Request parameters for apiProductsIdGet operation in ProductsApi.
 * @export
 * @interface ProductsApiApiProductsIdGetRequest
 */
export interface ProductsApiApiProductsIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductsApiApiProductsIdGet
     */
    readonly id: number
}

/**
 * Request parameters for apiProductsIdPatch operation in ProductsApi.
 * @export
 * @interface ProductsApiApiProductsIdPatchRequest
 */
export interface ProductsApiApiProductsIdPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductsApiApiProductsIdPatch
     */
    readonly id: number

    /**
     * 
     * @type {ShopUpdateProductRequestBody}
     * @memberof ProductsApiApiProductsIdPatch
     */
    readonly shopUpdateProductRequestBody?: ShopUpdateProductRequestBody
}

/**
 * Request parameters for apiProductsPost operation in ProductsApi.
 * @export
 * @interface ProductsApiApiProductsPostRequest
 */
export interface ProductsApiApiProductsPostRequest {
    /**
     * 
     * @type {ShopCreateProductRequestBody}
     * @memberof ProductsApiApiProductsPost
     */
    readonly shopCreateProductRequestBody?: ShopCreateProductRequestBody
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.BuyProduct
     * @param {ProductsApiApiProductsBuyIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public apiProductsBuyIdPost(requestParameters: ProductsApiApiProductsBuyIdPostRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).apiProductsBuyIdPost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexProducts, Shop.IndexStoreProducts
     * @param {ProductsApiApiProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public apiProductsGet(requestParameters: ProductsApiApiProductsGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).apiProductsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteProduct
     * @param {ProductsApiApiProductsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public apiProductsIdDelete(requestParameters: ProductsApiApiProductsIdDeleteRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).apiProductsIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewProduct, Shop.ViewStoreProduct
     * @param {ProductsApiApiProductsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public apiProductsIdGet(requestParameters: ProductsApiApiProductsIdGetRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).apiProductsIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateProduct
     * @param {ProductsApiApiProductsIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public apiProductsIdPatch(requestParameters: ProductsApiApiProductsIdPatchRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).apiProductsIdPatch(requestParameters.id, requestParameters.shopUpdateProductRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateProduct
     * @param {ProductsApiApiProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public apiProductsPost(requestParameters: ProductsApiApiProductsPostRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).apiProductsPost(requestParameters.shopCreateProductRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QRCodesApi - axios parameter creator
 * @export
 */
export const QRCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexQRCodes<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/QRCodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiQRCodesIdDelete', 'id', id)
            const localVarPath = `/Api/QRCodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiQRCodesIdGet', 'id', id)
            const localVarPath = `/Api/QRCodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopUpdateQRCodeRequestBody} [shopUpdateQRCodeRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesIdPatch: async (id: number, shopUpdateQRCodeRequestBody?: ShopUpdateQRCodeRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiQRCodesIdPatch', 'id', id)
            const localVarPath = `/Api/QRCodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopUpdateQRCodeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {ShopCreateQRCodeRequestBody} [shopCreateQRCodeRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesPost: async (shopCreateQRCodeRequestBody?: ShopCreateQRCodeRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/QRCodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopCreateQRCodeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QRCodesApi - functional programming interface
 * @export
 */
export const QRCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QRCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexQRCodes<br><b>Requires the following features to be enabled</b>: Shop
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQRCodesGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopIndexQRCodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQRCodesGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQRCodesIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQRCodesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQRCodesIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQRCodesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {number} id 
         * @param {ShopUpdateQRCodeRequestBody} [shopUpdateQRCodeRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQRCodesIdPatch(id: number, shopUpdateQRCodeRequestBody?: ShopUpdateQRCodeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQRCodesIdPatch(id, shopUpdateQRCodeRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {ShopCreateQRCodeRequestBody} [shopCreateQRCodeRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQRCodesPost(shopCreateQRCodeRequestBody?: ShopCreateQRCodeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopCreateQRCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQRCodesPost(shopCreateQRCodeRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QRCodesApi - factory interface
 * @export
 */
export const QRCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QRCodesApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexQRCodes<br><b>Requires the following features to be enabled</b>: Shop
         * @param {QRCodesApiApiQRCodesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesGet(requestParameters: QRCodesApiApiQRCodesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopIndexQRCodesResponse> {
            return localVarFp.apiQRCodesGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {QRCodesApiApiQRCodesIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesIdDelete(requestParameters: QRCodesApiApiQRCodesIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiQRCodesIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {QRCodesApiApiQRCodesIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesIdGet(requestParameters: QRCodesApiApiQRCodesIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiQRCodesIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {QRCodesApiApiQRCodesIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesIdPatch(requestParameters: QRCodesApiApiQRCodesIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiQRCodesIdPatch(requestParameters.id, requestParameters.shopUpdateQRCodeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateQRCode<br><b>Requires the following features to be enabled</b>: Shop
         * @param {QRCodesApiApiQRCodesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQRCodesPost(requestParameters: QRCodesApiApiQRCodesPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopCreateQRCodeResponse> {
            return localVarFp.apiQRCodesPost(requestParameters.shopCreateQRCodeRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiQRCodesGet operation in QRCodesApi.
 * @export
 * @interface QRCodesApiApiQRCodesGetRequest
 */
export interface QRCodesApiApiQRCodesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof QRCodesApiApiQRCodesGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof QRCodesApiApiQRCodesGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof QRCodesApiApiQRCodesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof QRCodesApiApiQRCodesGet
     */
    readonly pageSize?: number
}

/**
 * Request parameters for apiQRCodesIdDelete operation in QRCodesApi.
 * @export
 * @interface QRCodesApiApiQRCodesIdDeleteRequest
 */
export interface QRCodesApiApiQRCodesIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof QRCodesApiApiQRCodesIdDelete
     */
    readonly id: number
}

/**
 * Request parameters for apiQRCodesIdGet operation in QRCodesApi.
 * @export
 * @interface QRCodesApiApiQRCodesIdGetRequest
 */
export interface QRCodesApiApiQRCodesIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof QRCodesApiApiQRCodesIdGet
     */
    readonly id: number
}

/**
 * Request parameters for apiQRCodesIdPatch operation in QRCodesApi.
 * @export
 * @interface QRCodesApiApiQRCodesIdPatchRequest
 */
export interface QRCodesApiApiQRCodesIdPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof QRCodesApiApiQRCodesIdPatch
     */
    readonly id: number

    /**
     * 
     * @type {ShopUpdateQRCodeRequestBody}
     * @memberof QRCodesApiApiQRCodesIdPatch
     */
    readonly shopUpdateQRCodeRequestBody?: ShopUpdateQRCodeRequestBody
}

/**
 * Request parameters for apiQRCodesPost operation in QRCodesApi.
 * @export
 * @interface QRCodesApiApiQRCodesPostRequest
 */
export interface QRCodesApiApiQRCodesPostRequest {
    /**
     * 
     * @type {ShopCreateQRCodeRequestBody}
     * @memberof QRCodesApiApiQRCodesPost
     */
    readonly shopCreateQRCodeRequestBody?: ShopCreateQRCodeRequestBody
}

/**
 * QRCodesApi - object-oriented interface
 * @export
 * @class QRCodesApi
 * @extends {BaseAPI}
 */
export class QRCodesApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.IndexQRCodes<br><b>Requires the following features to be enabled</b>: Shop
     * @param {QRCodesApiApiQRCodesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QRCodesApi
     */
    public apiQRCodesGet(requestParameters: QRCodesApiApiQRCodesGetRequest = {}, options?: AxiosRequestConfig) {
        return QRCodesApiFp(this.configuration).apiQRCodesGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.DeleteQRCode<br><b>Requires the following features to be enabled</b>: Shop
     * @param {QRCodesApiApiQRCodesIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QRCodesApi
     */
    public apiQRCodesIdDelete(requestParameters: QRCodesApiApiQRCodesIdDeleteRequest, options?: AxiosRequestConfig) {
        return QRCodesApiFp(this.configuration).apiQRCodesIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.ViewQRCode<br><b>Requires the following features to be enabled</b>: Shop
     * @param {QRCodesApiApiQRCodesIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QRCodesApi
     */
    public apiQRCodesIdGet(requestParameters: QRCodesApiApiQRCodesIdGetRequest, options?: AxiosRequestConfig) {
        return QRCodesApiFp(this.configuration).apiQRCodesIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.UpdateQRCode<br><b>Requires the following features to be enabled</b>: Shop
     * @param {QRCodesApiApiQRCodesIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QRCodesApi
     */
    public apiQRCodesIdPatch(requestParameters: QRCodesApiApiQRCodesIdPatchRequest, options?: AxiosRequestConfig) {
        return QRCodesApiFp(this.configuration).apiQRCodesIdPatch(requestParameters.id, requestParameters.shopUpdateQRCodeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Shop.CreateQRCode<br><b>Requires the following features to be enabled</b>: Shop
     * @param {QRCodesApiApiQRCodesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QRCodesApi
     */
    public apiQRCodesPost(requestParameters: QRCodesApiApiQRCodesPostRequest = {}, options?: AxiosRequestConfig) {
        return QRCodesApiFp(this.configuration).apiQRCodesPost(requestParameters.shopCreateQRCodeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {StatusNotifyOnResetKeyPasswordSetRequestBody} [statusNotifyOnResetKeyPasswordSetRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusNotifyOnResetKeyPasswordSetPost: async (statusNotifyOnResetKeyPasswordSetRequestBody?: StatusNotifyOnResetKeyPasswordSetRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Status/NotifyOnResetKeyPasswordSet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statusNotifyOnResetKeyPasswordSetRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusServiceStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Status/ServiceStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} sendOk 
         * @param {boolean} sendMOTD 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusVersionGet: async (sendOk: boolean, sendMOTD: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendOk' is not null or undefined
            assertParamExists('apiStatusVersionGet', 'sendOk', sendOk)
            // verify required parameter 'sendMOTD' is not null or undefined
            assertParamExists('apiStatusVersionGet', 'sendMOTD', sendMOTD)
            const localVarPath = `/Api/Status/Version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sendOk !== undefined) {
                localVarQueryParameter['SendOk'] = sendOk;
            }

            if (sendMOTD !== undefined) {
                localVarQueryParameter['SendMOTD'] = sendMOTD;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {StatusNotifyOnResetKeyPasswordSetRequestBody} [statusNotifyOnResetKeyPasswordSetRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStatusNotifyOnResetKeyPasswordSetPost(statusNotifyOnResetKeyPasswordSetRequestBody?: StatusNotifyOnResetKeyPasswordSetRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStatusNotifyOnResetKeyPasswordSetPost(statusNotifyOnResetKeyPasswordSetRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStatusServiceStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusViewServiceStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStatusServiceStatusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} sendOk 
         * @param {boolean} sendMOTD 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStatusVersionGet(sendOk: boolean, sendMOTD: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusViewVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStatusVersionGet(sendOk, sendMOTD, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * 
         * @param {StatusApiApiStatusNotifyOnResetKeyPasswordSetPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusNotifyOnResetKeyPasswordSetPost(requestParameters: StatusApiApiStatusNotifyOnResetKeyPasswordSetPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiStatusNotifyOnResetKeyPasswordSetPost(requestParameters.statusNotifyOnResetKeyPasswordSetRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusServiceStatusGet(options?: AxiosRequestConfig): AxiosPromise<StatusViewServiceStatusResponse> {
            return localVarFp.apiStatusServiceStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StatusApiApiStatusVersionGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusVersionGet(requestParameters: StatusApiApiStatusVersionGetRequest, options?: AxiosRequestConfig): AxiosPromise<StatusViewVersionResponse> {
            return localVarFp.apiStatusVersionGet(requestParameters.sendOk, requestParameters.sendMOTD, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiStatusNotifyOnResetKeyPasswordSetPost operation in StatusApi.
 * @export
 * @interface StatusApiApiStatusNotifyOnResetKeyPasswordSetPostRequest
 */
export interface StatusApiApiStatusNotifyOnResetKeyPasswordSetPostRequest {
    /**
     * 
     * @type {StatusNotifyOnResetKeyPasswordSetRequestBody}
     * @memberof StatusApiApiStatusNotifyOnResetKeyPasswordSetPost
     */
    readonly statusNotifyOnResetKeyPasswordSetRequestBody?: StatusNotifyOnResetKeyPasswordSetRequestBody
}

/**
 * Request parameters for apiStatusVersionGet operation in StatusApi.
 * @export
 * @interface StatusApiApiStatusVersionGetRequest
 */
export interface StatusApiApiStatusVersionGetRequest {
    /**
     * 
     * @type {boolean}
     * @memberof StatusApiApiStatusVersionGet
     */
    readonly sendOk: boolean

    /**
     * 
     * @type {boolean}
     * @memberof StatusApiApiStatusVersionGet
     */
    readonly sendMOTD: boolean
}

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * 
     * @param {StatusApiApiStatusNotifyOnResetKeyPasswordSetPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public apiStatusNotifyOnResetKeyPasswordSetPost(requestParameters: StatusApiApiStatusNotifyOnResetKeyPasswordSetPostRequest = {}, options?: AxiosRequestConfig) {
        return StatusApiFp(this.configuration).apiStatusNotifyOnResetKeyPasswordSetPost(requestParameters.statusNotifyOnResetKeyPasswordSetRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public apiStatusServiceStatusGet(options?: AxiosRequestConfig) {
        return StatusApiFp(this.configuration).apiStatusServiceStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StatusApiApiStatusVersionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public apiStatusVersionGet(requestParameters: StatusApiApiStatusVersionGetRequest, options?: AxiosRequestConfig) {
        return StatusApiFp(this.configuration).apiStatusVersionGet(requestParameters.sendOk, requestParameters.sendMOTD, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserGroupsApi - axios parameter creator
 * @export
 */
export const UserGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.IndexUserGroups
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/UserGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.DeleteUserGroup
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserGroupsIdDelete', 'id', id)
            const localVarPath = `/Api/UserGroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.ViewUserGroup
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserGroupsIdGet', 'id', id)
            const localVarPath = `/Api/UserGroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.UpdateUserGroup
         * @param {number} id 
         * @param {AuthUpdateUserGroupRequestBody} [authUpdateUserGroupRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsIdPatch: async (id: number, authUpdateUserGroupRequestBody?: AuthUpdateUserGroupRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserGroupsIdPatch', 'id', id)
            const localVarPath = `/Api/UserGroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authUpdateUserGroupRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.CreateUserGroup
         * @param {AuthCreateUserGroupRequestBody} [authCreateUserGroupRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsPost: async (authCreateUserGroupRequestBody?: AuthCreateUserGroupRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/UserGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authCreateUserGroupRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserGroupsApi - functional programming interface
 * @export
 */
export const UserGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.IndexUserGroups
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserGroupsGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthIndexUserGroupsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserGroupsGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.DeleteUserGroup
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserGroupsIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserGroupsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.ViewUserGroup
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserGroupsIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthViewUserGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserGroupsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.UpdateUserGroup
         * @param {number} id 
         * @param {AuthUpdateUserGroupRequestBody} [authUpdateUserGroupRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserGroupsIdPatch(id: number, authUpdateUserGroupRequestBody?: AuthUpdateUserGroupRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserGroupsIdPatch(id, authUpdateUserGroupRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.CreateUserGroup
         * @param {AuthCreateUserGroupRequestBody} [authCreateUserGroupRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserGroupsPost(authCreateUserGroupRequestBody?: AuthCreateUserGroupRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthCreateUserGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserGroupsPost(authCreateUserGroupRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserGroupsApi - factory interface
 * @export
 */
export const UserGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserGroupsApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.IndexUserGroups
         * @param {UserGroupsApiApiUserGroupsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsGet(requestParameters: UserGroupsApiApiUserGroupsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AuthIndexUserGroupsResponse>> {
            return localVarFp.apiUserGroupsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.DeleteUserGroup
         * @param {UserGroupsApiApiUserGroupsIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsIdDelete(requestParameters: UserGroupsApiApiUserGroupsIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUserGroupsIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.ViewUserGroup
         * @param {UserGroupsApiApiUserGroupsIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsIdGet(requestParameters: UserGroupsApiApiUserGroupsIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AuthViewUserGroupResponse> {
            return localVarFp.apiUserGroupsIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.UpdateUserGroup
         * @param {UserGroupsApiApiUserGroupsIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsIdPatch(requestParameters: UserGroupsApiApiUserGroupsIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUserGroupsIdPatch(requestParameters.id, requestParameters.authUpdateUserGroupRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.CreateUserGroup
         * @param {UserGroupsApiApiUserGroupsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGroupsPost(requestParameters: UserGroupsApiApiUserGroupsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AuthCreateUserGroupResponse> {
            return localVarFp.apiUserGroupsPost(requestParameters.authCreateUserGroupRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiUserGroupsGet operation in UserGroupsApi.
 * @export
 * @interface UserGroupsApiApiUserGroupsGetRequest
 */
export interface UserGroupsApiApiUserGroupsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UserGroupsApiApiUserGroupsGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof UserGroupsApiApiUserGroupsGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof UserGroupsApiApiUserGroupsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof UserGroupsApiApiUserGroupsGet
     */
    readonly pageSize?: number
}

/**
 * Request parameters for apiUserGroupsIdDelete operation in UserGroupsApi.
 * @export
 * @interface UserGroupsApiApiUserGroupsIdDeleteRequest
 */
export interface UserGroupsApiApiUserGroupsIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof UserGroupsApiApiUserGroupsIdDelete
     */
    readonly id: number
}

/**
 * Request parameters for apiUserGroupsIdGet operation in UserGroupsApi.
 * @export
 * @interface UserGroupsApiApiUserGroupsIdGetRequest
 */
export interface UserGroupsApiApiUserGroupsIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof UserGroupsApiApiUserGroupsIdGet
     */
    readonly id: number
}

/**
 * Request parameters for apiUserGroupsIdPatch operation in UserGroupsApi.
 * @export
 * @interface UserGroupsApiApiUserGroupsIdPatchRequest
 */
export interface UserGroupsApiApiUserGroupsIdPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof UserGroupsApiApiUserGroupsIdPatch
     */
    readonly id: number

    /**
     * 
     * @type {AuthUpdateUserGroupRequestBody}
     * @memberof UserGroupsApiApiUserGroupsIdPatch
     */
    readonly authUpdateUserGroupRequestBody?: AuthUpdateUserGroupRequestBody
}

/**
 * Request parameters for apiUserGroupsPost operation in UserGroupsApi.
 * @export
 * @interface UserGroupsApiApiUserGroupsPostRequest
 */
export interface UserGroupsApiApiUserGroupsPostRequest {
    /**
     * 
     * @type {AuthCreateUserGroupRequestBody}
     * @memberof UserGroupsApiApiUserGroupsPost
     */
    readonly authCreateUserGroupRequestBody?: AuthCreateUserGroupRequestBody
}

/**
 * UserGroupsApi - object-oriented interface
 * @export
 * @class UserGroupsApi
 * @extends {BaseAPI}
 */
export class UserGroupsApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.IndexUserGroups
     * @param {UserGroupsApiApiUserGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsApi
     */
    public apiUserGroupsGet(requestParameters: UserGroupsApiApiUserGroupsGetRequest = {}, options?: AxiosRequestConfig) {
        return UserGroupsApiFp(this.configuration).apiUserGroupsGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.DeleteUserGroup
     * @param {UserGroupsApiApiUserGroupsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsApi
     */
    public apiUserGroupsIdDelete(requestParameters: UserGroupsApiApiUserGroupsIdDeleteRequest, options?: AxiosRequestConfig) {
        return UserGroupsApiFp(this.configuration).apiUserGroupsIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.ViewUserGroup
     * @param {UserGroupsApiApiUserGroupsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsApi
     */
    public apiUserGroupsIdGet(requestParameters: UserGroupsApiApiUserGroupsIdGetRequest, options?: AxiosRequestConfig) {
        return UserGroupsApiFp(this.configuration).apiUserGroupsIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.UpdateUserGroup
     * @param {UserGroupsApiApiUserGroupsIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsApi
     */
    public apiUserGroupsIdPatch(requestParameters: UserGroupsApiApiUserGroupsIdPatchRequest, options?: AxiosRequestConfig) {
        return UserGroupsApiFp(this.configuration).apiUserGroupsIdPatch(requestParameters.id, requestParameters.authUpdateUserGroupRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Auth.CreateUserGroup
     * @param {UserGroupsApiApiUserGroupsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsApi
     */
    public apiUserGroupsPost(requestParameters: UserGroupsApiApiUserGroupsPostRequest = {}, options?: AxiosRequestConfig) {
        return UserGroupsApiFp(this.configuration).apiUserGroupsPost(requestParameters.authCreateUserGroupRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.IndexUsers<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet: async (filters?: string, sorts?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (sorts !== undefined) {
                localVarQueryParameter['Sorts'] = sorts;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.DeleteUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdDelete', 'id', id)
            const localVarPath = `/Api/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.ViewUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdGet', 'id', id)
            const localVarPath = `/Api/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.UpdateUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} id 
         * @param {UsersUpdateUserRequestBody} [usersUpdateUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch: async (id: string, usersUpdateUserRequestBody?: UsersUpdateUserRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'id', id)
            const localVarPath = `/Api/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpdateUserRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.KickAllUsers<br><b>Requires the following features to be enabled</b>: Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersKickAllPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Users/Kick/All`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.KickUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersKickIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersKickIdPost', 'id', id)
            const localVarPath = `/Api/Users/Kick/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Requires the following features to be enabled</b>: Users
         * @param {string} [verifyUrl] 
         * @param {string} [verifyTokenQueryKey] 
         * @param {UsersCreateUserRequestBody} [usersCreateUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost: async (verifyUrl?: string, verifyTokenQueryKey?: string, usersCreateUserRequestBody?: UsersCreateUserRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (verifyUrl !== undefined) {
                localVarQueryParameter['verifyUrl'] = verifyUrl;
            }

            if (verifyTokenQueryKey !== undefined) {
                localVarQueryParameter['verifyTokenQueryKey'] = verifyTokenQueryKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersCreateUserRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.IndexUsers<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} [filters] 
         * @param {string} [sorts] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersGet(filters?: string, sorts?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersIndexUsersResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersGet(filters, sorts, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.DeleteUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.ViewUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersViewUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.UpdateUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} id 
         * @param {UsersUpdateUserRequestBody} [usersUpdateUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdPatch(id: string, usersUpdateUserRequestBody?: UsersUpdateUserRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdPatch(id, usersUpdateUserRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.KickAllUsers<br><b>Requires the following features to be enabled</b>: Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersKickAllPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersKickAllPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.KickUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersKickIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersKickIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <b>Requires the following features to be enabled</b>: Users
         * @param {string} [verifyUrl] 
         * @param {string} [verifyTokenQueryKey] 
         * @param {UsersCreateUserRequestBody} [usersCreateUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersPost(verifyUrl?: string, verifyTokenQueryKey?: string, usersCreateUserRequestBody?: UsersCreateUserRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersPost(verifyUrl, verifyTokenQueryKey, usersCreateUserRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.IndexUsers<br><b>Requires the following features to be enabled</b>: Users
         * @param {UsersApiApiUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(requestParameters: UsersApiApiUsersGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<UsersIndexUsersResponse>> {
            return localVarFp.apiUsersGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.DeleteUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {UsersApiApiUsersIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(requestParameters: UsersApiApiUsersIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUsersIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.ViewUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {UsersApiApiUsersIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(requestParameters: UsersApiApiUsersIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<UsersViewUserResponse> {
            return localVarFp.apiUsersIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.UpdateUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {UsersApiApiUsersIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch(requestParameters: UsersApiApiUsersIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUsersIdPatch(requestParameters.id, requestParameters.usersUpdateUserRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.KickAllUsers<br><b>Requires the following features to be enabled</b>: Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersKickAllPost(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUsersKickAllPost(options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.KickUser<br><b>Requires the following features to be enabled</b>: Users
         * @param {UsersApiApiUsersKickIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersKickIdPost(requestParameters: UsersApiApiUsersKickIdPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUsersKickIdPost(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * <b>Requires the following features to be enabled</b>: Users
         * @param {UsersApiApiUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(requestParameters: UsersApiApiUsersPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUsersPost(requestParameters.verifyUrl, requestParameters.verifyTokenQueryKey, requestParameters.usersCreateUserRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiUsersGet operation in UsersApi.
 * @export
 * @interface UsersApiApiUsersGetRequest
 */
export interface UsersApiApiUsersGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiApiUsersGet
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiApiUsersGet
     */
    readonly sorts?: string

    /**
     * 
     * @type {number}
     * @memberof UsersApiApiUsersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof UsersApiApiUsersGet
     */
    readonly pageSize?: number
}

/**
 * Request parameters for apiUsersIdDelete operation in UsersApi.
 * @export
 * @interface UsersApiApiUsersIdDeleteRequest
 */
export interface UsersApiApiUsersIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiApiUsersIdDelete
     */
    readonly id: string
}

/**
 * Request parameters for apiUsersIdGet operation in UsersApi.
 * @export
 * @interface UsersApiApiUsersIdGetRequest
 */
export interface UsersApiApiUsersIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiApiUsersIdGet
     */
    readonly id: string
}

/**
 * Request parameters for apiUsersIdPatch operation in UsersApi.
 * @export
 * @interface UsersApiApiUsersIdPatchRequest
 */
export interface UsersApiApiUsersIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiApiUsersIdPatch
     */
    readonly id: string

    /**
     * 
     * @type {UsersUpdateUserRequestBody}
     * @memberof UsersApiApiUsersIdPatch
     */
    readonly usersUpdateUserRequestBody?: UsersUpdateUserRequestBody
}

/**
 * Request parameters for apiUsersKickIdPost operation in UsersApi.
 * @export
 * @interface UsersApiApiUsersKickIdPostRequest
 */
export interface UsersApiApiUsersKickIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiApiUsersKickIdPost
     */
    readonly id: string
}

/**
 * Request parameters for apiUsersPost operation in UsersApi.
 * @export
 * @interface UsersApiApiUsersPostRequest
 */
export interface UsersApiApiUsersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiApiUsersPost
     */
    readonly verifyUrl?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiApiUsersPost
     */
    readonly verifyTokenQueryKey?: string

    /**
     * 
     * @type {UsersCreateUserRequestBody}
     * @memberof UsersApiApiUsersPost
     */
    readonly usersCreateUserRequestBody?: UsersCreateUserRequestBody
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.IndexUsers<br><b>Requires the following features to be enabled</b>: Users
     * @param {UsersApiApiUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersGet(requestParameters: UsersApiApiUsersGetRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersGet(requestParameters.filters, requestParameters.sorts, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.DeleteUser<br><b>Requires the following features to be enabled</b>: Users
     * @param {UsersApiApiUsersIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersIdDelete(requestParameters: UsersApiApiUsersIdDeleteRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.ViewUser<br><b>Requires the following features to be enabled</b>: Users
     * @param {UsersApiApiUsersIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersIdGet(requestParameters: UsersApiApiUsersIdGetRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.UpdateUser<br><b>Requires the following features to be enabled</b>: Users
     * @param {UsersApiApiUsersIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersIdPatch(requestParameters: UsersApiApiUsersIdPatchRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersIdPatch(requestParameters.id, requestParameters.usersUpdateUserRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.KickAllUsers<br><b>Requires the following features to be enabled</b>: Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersKickAllPost(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersKickAllPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires verified email</b><br><b>Requires one of the following permissions</b>: Users.KickUser<br><b>Requires the following features to be enabled</b>: Users
     * @param {UsersApiApiUsersKickIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersKickIdPost(requestParameters: UsersApiApiUsersKickIdPostRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersKickIdPost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <b>Requires the following features to be enabled</b>: Users
     * @param {UsersApiApiUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersPost(requestParameters: UsersApiApiUsersPostRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersPost(requestParameters.verifyUrl, requestParameters.verifyTokenQueryKey, requestParameters.usersCreateUserRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


